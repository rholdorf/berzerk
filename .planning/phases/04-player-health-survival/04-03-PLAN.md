---
phase: 04-player-health-survival
plan: 03
type: execute
wave: 2
depends_on: ["04-01", "04-02"]
files_modified:
  - Berzerk/BerzerkGame.cs
  - Berzerk/Source/Controllers/PlayerController.cs
autonomous: false

must_haves:
  truths:
    - "H key deals 10 HP damage to player"
    - "Damage triggers red vignette flash"
    - "Health bar displays and updates in real-time"
    - "Player dies when health reaches zero"
    - "Death triggers fade to black sequence"
    - "Game over screen appears after fade completes"
    - "R key restarts game from game over state"
    - "Player cannot move or shoot when dead"
  artifacts:
    - path: "Berzerk/BerzerkGame.cs"
      provides: "Integrated health system with game state management"
      contains: ["GameState", "HealthSystem", "DamageVignette", "ScreenFade", "HealthBar", "GameOverScreen"]
    - path: "Berzerk/Source/Controllers/PlayerController.cs"
      provides: "Player controller with disabled input when dead"
      contains: "IsEnabled"
  key_links:
    - from: "BerzerkGame.Update"
      to: "HealthSystem.TakeDamage"
      via: "H key press"
      pattern: "IsKeyPressed.*Keys\\.H.*TakeDamage"
    - from: "HealthSystem.OnDamageTaken"
      to: "DamageVignette.Trigger"
      via: "Event subscription"
      pattern: "OnDamageTaken\\s*\\+=.*Trigger"
    - from: "HealthSystem.OnDeath"
      to: "GameState change"
      via: "Event subscription"
      pattern: "OnDeath\\s*\\+=.*Dying"
    - from: "GameState.GameOver"
      to: "R key restart"
      via: "Input check in GameOver state"
      pattern: "GameOver.*IsKeyPressed.*Keys\\.R"
---

<objective>
Integrate all health and survival components into BerzerkGame with proper game state management.

Purpose: Complete the player health and survival system by wiring all components together and implementing the game state machine (Playing -> Dying -> GameOver -> restart).
Output: Fully functional health system with test damage (H key), visual feedback, death sequence, and restart capability.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-player-health-&-survival**/04-CONTEXT.md
@.planning/phases/04-player-health-&-survival**/04-RESEARCH.md
@.planning/phases/04-player-health-survival/04-01-SUMMARY.md
@.planning/phases/04-player-health-survival/04-02-SUMMARY.md

# Files to modify
@Berzerk/BerzerkGame.cs
@Berzerk/Source/Controllers/PlayerController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add IsEnabled to PlayerController</name>
  <files>Berzerk/Source/Controllers/PlayerController.cs</files>
  <action>
Add IsEnabled property to PlayerController to disable input when player is dead:

1. Add public property:
```csharp
public bool IsEnabled { get; set; } = true;
```

2. Guard the Update method - early return if disabled:
```csharp
public void Update(GameTime gameTime)
{
    if (!IsEnabled) return;

    // ... rest of existing update logic
}
```

This allows BerzerkGame to disable player control during death/game-over without modifying the controller's internal logic.

Key decision from CONTEXT.md:
- "Physics: Character momentum continues during death (slides to natural stop)"
- Since we're using tank controls without physics, disabling input immediately is the cleanest approach
  </action>
  <verify>
    `dotnet build Berzerk/` compiles successfully
  </verify>
  <done>
    PlayerController has IsEnabled property that gates Update logic
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate health system into BerzerkGame</name>
  <files>Berzerk/BerzerkGame.cs</files>
  <action>
Add comprehensive health system integration with game state management:

1. Add using statements at top:
```csharp
using Berzerk.Source.Player;
```

2. Add GameState enum inside BerzerkGame class (or before class):
```csharp
public enum GameState
{
    Playing,
    Dying,
    GameOver
}
```

3. Add new fields:
```csharp
// Health and survival
private HealthSystem _healthSystem;
private DamageVignette _damageVignette;
private ScreenFade _screenFade;
private HealthBar _healthBar;
private GameOverScreen _gameOverScreen;
private GameState _gameState = GameState.Playing;
```

4. In Initialize(), create health system and wire events:
```csharp
// Initialize health system
_healthSystem = new HealthSystem();
_healthSystem.OnDamageTaken += () => _damageVignette.Trigger();
_healthSystem.OnDeath += () =>
{
    _gameState = GameState.Dying;
    _screenFade.FadeToBlack(1.5f);  // 1.5 second fade
    _playerController.IsEnabled = false;
    Console.WriteLine("Player died!");
};
```

5. In LoadContent(), initialize UI components:
```csharp
// Load health UI
_damageVignette = new DamageVignette();
_damageVignette.LoadContent(GraphicsDevice);

_screenFade = new ScreenFade();
_screenFade.LoadContent(GraphicsDevice);

_healthBar = new HealthBar();
_healthBar.LoadContent(GraphicsDevice);

_gameOverScreen = new GameOverScreen();
_gameOverScreen.LoadContent(Content, GraphicsDevice);
```

6. Refactor Update() to use game state machine:
```csharp
protected override void Update(GameTime gameTime)
{
    _inputManager.Update();
    float deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds;

    switch (_gameState)
    {
        case GameState.Playing:
            UpdatePlaying(gameTime, deltaTime);
            break;
        case GameState.Dying:
            UpdateDying(deltaTime);
            break;
        case GameState.GameOver:
            UpdateGameOver();
            break;
    }

    base.Update(gameTime);
}

private void UpdatePlaying(GameTime gameTime, float deltaTime)
{
    // Test damage: H key deals 10 HP
    if (_inputManager.IsKeyPressed(Keys.H))
    {
        _healthSystem.TakeDamage(10);
        Console.WriteLine($"Damage! Health: {_healthSystem.CurrentHealth}/{_healthSystem.MaxHealth}");
    }

    // Existing player/camera/combat updates
    _playerController.Update(gameTime);
    _camera.Update(gameTime);

    // Combat update (existing code)
    bool isFiring = _inputManager.IsLeftMouseHeld();
    Vector3 spawnPos = _playerController.Transform.Position + Vector3.Up * 1.5f;
    Vector3 aimDir = _camera.Forward;
    _weaponSystem.Update(gameTime, isFiring, spawnPos, aimDir);

    _projectileManager.Update(deltaTime);
    _targetManager.Update(deltaTime);
    _targetManager.CheckProjectileCollisions(_projectileManager.GetActiveProjectiles());
    _targetManager.CheckPickupCollection(_playerController.Transform.Position, _ammoSystem);

    // R key respawns targets (existing)
    if (_inputManager.IsKeyPressed(Keys.R))
    {
        _targetManager.RespawnTargets();
        Console.WriteLine("Targets respawned!");
    }

    // Animation switching (existing code - keep as is)
    // ... D1/D2/D3 animation switch logic ...

    // Update animations and effects
    _currentModel?.Update(gameTime);
    _damageVignette.Update(deltaTime);

    // Exit handling
    if (_inputManager.IsKeyPressed(Keys.Escape))
        Exit();
}

private void UpdateDying(float deltaTime)
{
    _screenFade.Update(deltaTime);
    _damageVignette.Update(deltaTime);  // Continue fading any active vignette

    if (_screenFade.IsComplete)
    {
        _gameState = GameState.GameOver;
        Console.WriteLine("Game Over - Press R to restart");
    }
}

private void UpdateGameOver()
{
    if (_inputManager.IsKeyPressed(Keys.R))
    {
        RestartGame();
    }

    if (_inputManager.IsKeyPressed(Keys.Escape))
        Exit();
}

private void RestartGame()
{
    _healthSystem.Reset();
    _screenFade.Reset();
    _playerController.IsEnabled = true;
    _playerController.Transform.Position = Vector3.Zero;  // Reset position
    _gameState = GameState.Playing;
    _targetManager.RespawnTargets();
    _ammoSystem = new AmmoSystem();  // Reset ammo
    _weaponSystem = new WeaponSystem(_ammoSystem, _projectileManager);
    Console.WriteLine("Game restarted!");
}
```

7. Update Draw() to render health UI and handle game states:
```csharp
protected override void Draw(GameTime gameTime)
{
    GraphicsDevice.Clear(Color.CornflowerBlue);

    // Draw 3D content (only when not fully faded to black)
    if (_screenFade.Alpha < 0.99f)
    {
        // ... existing 3D drawing code (floor, walls, combat, model) ...
    }

    // Draw 2D UI
    _spriteBatch.Begin();

    // Always draw crosshair during gameplay
    if (_gameState == GameState.Playing)
    {
        _crosshair.Draw(_spriteBatch, GraphicsDevice.Viewport);
        _healthBar.Draw(_spriteBatch, _healthSystem.CurrentHealth, _healthSystem.MaxHealth);
    }

    // Draw damage vignette (always, handles own alpha)
    _damageVignette.Draw(_spriteBatch, GraphicsDevice.Viewport);

    // Draw screen fade (always, handles own alpha)
    _screenFade.Draw(_spriteBatch, GraphicsDevice.Viewport);

    // Draw game over screen when in GameOver state
    if (_gameState == GameState.GameOver)
    {
        _gameOverScreen.Draw(_spriteBatch, GraphicsDevice.Viewport);
    }

    _spriteBatch.End();

    base.Draw(gameTime);
}
```

8. Update controls help text in LoadContent():
```csharp
Console.WriteLine("\n=== Controls ===");
Console.WriteLine("WASD/QE: Move player (tank controls)");
Console.WriteLine("Mouse: Aim (crosshair)");
Console.WriteLine("Left Mouse: Fire (hold for auto-fire)");
Console.WriteLine("Right-click + drag: Orbit camera");
Console.WriteLine("Scroll wheel: Zoom camera");
Console.WriteLine("H: Test damage (10 HP)");
Console.WriteLine("R: Respawn targets / Restart (game over)");
Console.WriteLine("1/2/3: Switch animations");
Console.WriteLine("Escape: Exit");
Console.WriteLine("================\n");
```

Key integration points:
- GameState enum controls update/draw flow
- HealthSystem events wire to vignette and state transitions
- PlayerController.IsEnabled disables input during death
- RestartGame() resets all systems cleanly
- Draw order: 3D -> crosshair/healthbar -> vignette -> fade -> game over
  </action>
  <verify>
    `dotnet build Berzerk/` compiles successfully
  </verify>
  <done>
    BerzerkGame integrates all health components with game state machine, H key test damage, death sequence, and R key restart
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 3: Verify complete health and survival system</name>
  <what-built>
Complete player health and survival system:
- Health bar in top-left showing current HP
- H key deals 10 HP damage with red vignette flash
- Death at 0 HP triggers fade to black
- Game over screen with restart prompt
- R key restarts game from game over
  </what-built>
  <how-to-verify>
1. Run the game: `dotnet run --project Berzerk/`
2. Observe health bar in top-left corner (green, full)
3. Press H key once - expect:
   - Red vignette flash on screen edges
   - Console: "Damage! Health: 90/200"
   - Health bar decreases slightly
4. Press H key 9 more times (10 total) - expect:
   - Health reaches 0
   - Console: "Player died!"
   - Screen fades to black over ~1.5 seconds
   - Player stops responding to WASD
5. After fade completes - expect:
   - Console: "Game Over - Press R to restart"
   - Black screen with "GAME OVER / Press R to Restart" text
6. Press R key - expect:
   - Console: "Game restarted!"
   - Game returns to playing state
   - Health bar full again
   - Player can move again
7. Verify player input is disabled during death:
   - Press H until death
   - Try WASD/shooting during fade - should not work
  </how-to-verify>
  <resume-signal>Type "approved" if all behaviors work correctly, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. `dotnet build Berzerk/` compiles without errors
2. Game runs and displays health bar
3. H key damage -> vignette flash -> health decreases
4. 10 hits -> death -> fade to black -> game over screen
5. R key restarts cleanly
6. All controls help text updated
</verification>

<success_criteria>
- HEALTH-01: Player has health points (HP bar displays in top-left)
- HEALTH-02: Player takes damage when hit (H key = 10 HP damage)
- HEALTH-03: Player dies when health reaches zero (input disabled, death sequence)
- HEALTH-04: Game over state when player dies (black screen with restart prompt)
- Visual feedback: Red vignette on damage, fade to black on death
- Restart works correctly: R key resets all systems
</success_criteria>

<output>
After completion, create `.planning/phases/04-player-health-survival/04-03-SUMMARY.md`
</output>
