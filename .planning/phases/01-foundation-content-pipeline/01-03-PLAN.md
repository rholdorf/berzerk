---
phase: 01-foundation-content-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - Berzerk/Source/Input/InputManager.cs
  - Berzerk/BerzerkGame.cs
autonomous: true

must_haves:
  truths:
    - "Keyboard input is detected and tracked across frames"
    - "Mouse input is detected with position and button states"
    - "Key press events are detected (not just held state)"
    - "Input state is updated once per frame in game loop"
  artifacts:
    - path: "Berzerk/Source/Input/InputManager.cs"
      provides: "Centralized input handling with state tracking"
      contains: "class InputManager"
      min_lines: 40
  key_links:
    - from: "Berzerk/BerzerkGame.cs"
      to: "Berzerk/Source/Input/InputManager.cs"
      via: "Update() calls InputManager.Update()"
      pattern: "_inputManager\\.Update\\(\\)"
---

<objective>
Implement input handling system with keyboard and mouse support

Purpose: Input handling is fundamental to the game - needed for player movement (Phase 2) and shooting (Phase 3). Building it now validates the polling-based input pattern from research.
Output: InputManager class integrated into game loop, responding to keyboard and mouse
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-content-pipeline/01-RESEARCH.md
@.planning/phases/01-foundation-content-pipeline/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create InputManager with State Tracking</name>
  <files>
    Berzerk/Source/Input/InputManager.cs
  </files>
  <action>
Create the InputManager class following the pattern from RESEARCH.md:

1. Create directory structure: Berzerk/Source/Input/

2. Create InputManager.cs with:
   - Private fields for previous and current KeyboardState
   - Private fields for previous and current MouseState
   - Update() method that shifts current to previous and samples new state
   - IsKeyPressed(Keys key) - true only on the frame key goes down
   - IsKeyHeld(Keys key) - true while key is held
   - IsKeyReleased(Keys key) - true only on the frame key goes up
   - IsLeftMousePressed() - true only on frame left button goes down
   - IsRightMousePressed() - true only on frame right button goes down
   - MousePosition property (Point)
   - MouseDelta property (Point) - difference from previous frame

3. Follow MonoGame polling pattern exactly:
   - Call Keyboard.GetState() and Mouse.GetState() once per frame only
   - Track previous frame state for edge detection
   - Never call GetState() multiple times per frame (anti-pattern from research)

4. Use Microsoft.Xna.Framework.Input namespace for KeyboardState, MouseState, Keys, ButtonState.

Keep the class simple and focused. It's a service that other systems will use.
  </action>
  <verify>
```bash
dotnet build Berzerk/Berzerk.csproj
```
Build succeeds. InputManager class compiles with all input methods.
  </verify>
  <done>
InputManager class exists with keyboard and mouse state tracking. All input query methods work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate InputManager into Game Loop</name>
  <files>
    Berzerk/BerzerkGame.cs
  </files>
  <action>
Wire InputManager into the game's Update loop and add a simple test:

1. Add private field: private InputManager _inputManager;

2. In Initialize() or constructor:
   - Create InputManager instance: _inputManager = new InputManager();

3. In Update(GameTime gameTime):
   - Call _inputManager.Update() at the START of Update (before any input checks)
   - Add test: if Escape key is pressed, call Exit() to close game
   - Add test: if Space key is pressed, log to Debug output (or change background color briefly)

4. Add using statement for the Input namespace.

5. Optionally in Draw():
   - If left mouse button is held, draw different background color
   - This provides visual confirmation input is working

The tests confirm:
- Keyboard polling works (Escape exits)
- Key press detection works (Space triggers once per press, not every frame)
- Mouse polling works (left button changes display)

Remove or comment out the visual tests before committing - they're just for verification.
  </action>
  <verify>
```bash
dotnet run --project Berzerk/Berzerk.csproj
```
1. Game window opens
2. Press Escape - game closes
3. (If visual test left in) Hold Space - see effect; tap Space multiple times - triggers once per tap
4. (If visual test left in) Hold left mouse - see effect
  </verify>
  <done>
InputManager is created and updated in game loop. Escape closes game. Input is responsive.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Solution builds:
   ```bash
   dotnet build Berzerk.sln
   ```

2. Game runs and responds to input:
   ```bash
   dotnet run --project Berzerk/Berzerk.csproj
   ```
   - Press Escape: game closes
   - Other keys and mouse: no crashes

3. InputManager is properly wired:
   - Update() is called in game Update()
   - Input checks work (verified by Escape key behavior)
</verification>

<success_criteria>
- [ ] InputManager.cs exists in Berzerk/Source/Input/
- [ ] InputManager has Update(), IsKeyPressed(), IsKeyHeld(), IsKeyReleased()
- [ ] InputManager has mouse methods and properties
- [ ] BerzerkGame.Update() calls _inputManager.Update()
- [ ] Pressing Escape key closes the game
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-content-pipeline/01-03-SUMMARY.md`
</output>
