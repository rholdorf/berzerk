---
phase: 03-core-combat-system
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - Berzerk/Source/Combat/ProjectileRenderer.cs
  - Berzerk/Source/Combat/ProjectileManager.cs
  - Berzerk/Source/Combat/ImpactEffect.cs
autonomous: true

must_haves:
  truths:
    - "Projectiles render as glowing spheres in 3D space"
    - "Projectiles collide with walls and disappear"
    - "Impact effects appear at collision points"
  artifacts:
    - path: "Berzerk/Source/Combat/ProjectileRenderer.cs"
      provides: "Sphere mesh and emissive rendering"
      contains: "BasicEffect"
    - path: "Berzerk/Source/Combat/ImpactEffect.cs"
      provides: "Fading glow at impact point"
      contains: "class ImpactEffect"
  key_links:
    - from: "ProjectileManager"
      to: "Wall collision"
      via: "BoundingSphere.Intersects(BoundingBox)"
      pattern: "Intersects.*BoundingBox"
    - from: "ProjectileRenderer"
      to: "BasicEffect"
      via: "EmissiveColor for glow"
      pattern: "EmissiveColor"
---

<objective>
Add visual rendering for projectiles (glowing spheres) and collision detection with walls including impact effects.

Purpose: Makes projectiles visible and interactive with the environment. Uses BasicEffect emissive for simple glow effect.
Output: ProjectileRenderer with sphere mesh, collision detection in ProjectileManager, ImpactEffect for visual feedback.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-core-combat-system/03-CONTEXT.md
@.planning/phases/03-core-combat-system/03-RESEARCH.md
@.planning/phases/03-core-combat-system/03-01-SUMMARY.md
@Berzerk/Source/Combat/Projectile.cs
@Berzerk/Source/Combat/ProjectileManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProjectileRenderer with sphere mesh and emissive glow</name>
  <files>
    Berzerk/Source/Combat/ProjectileRenderer.cs
  </files>
  <action>
Create ProjectileRenderer.cs:
- Namespace: Berzerk.Source.Combat
- Public class ProjectileRenderer with:
  - Private GraphicsDevice _graphicsDevice
  - Private BasicEffect _effect
  - Private VertexPositionNormalTexture[] _sphereVertices
  - Private short[] _sphereIndices
  - Private const int SPHERE_SEGMENTS = 8 (low poly for arcade style)
  - Private const float SPHERE_RADIUS = 0.2f (matches Projectile.Radius)

Constructor(GraphicsDevice graphicsDevice):
- Store device reference
- Call GenerateSphereMesh() to build vertex/index buffers
- Create BasicEffect with:
  - VertexColorEnabled = false
  - LightingEnabled = false (emissive only, no shadows)
  - EmissiveColor = new Vector3(0.3f, 0.9f, 1.0f) - cyan laser
  - DiffuseColor = same cyan color

GenerateSphereMesh():
- Generate UV sphere with SPHERE_SEGMENTS latitude/longitude
- Use VertexPositionNormalTexture for vertex format
- Calculate normals pointing outward
- Store in _sphereVertices and _sphereIndices
- Triangulate properly (degenerate triangles at poles are OK for low-poly)

Draw(IReadOnlyList<Projectile> projectiles, Matrix view, Matrix projection):
- Set _effect.View and _effect.Projection
- For each active projectile:
  - Set _effect.World = Matrix.CreateScale(SPHERE_RADIUS) * Matrix.CreateTranslation(projectile.Transform.Position)
  - For each pass in _effect.CurrentTechnique.Passes:
    - pass.Apply()
    - DrawUserIndexedPrimitives with sphere mesh

Tip: Sphere generation formula:
- For each latitude ring i (0 to segments):
  - phi = PI * i / segments
  - For each longitude j (0 to segments):
    - theta = 2*PI * j / segments
    - x = sin(phi) * cos(theta)
    - y = cos(phi)
    - z = sin(phi) * sin(theta)
  </action>
  <verify>
    dotnet build Berzerk/Berzerk.csproj
  </verify>
  <done>
    ProjectileRenderer compiles with sphere mesh generation and BasicEffect emissive rendering
  </done>
</task>

<task type="auto">
  <name>Task 2: Add wall collision detection to ProjectileManager and create ImpactEffect</name>
  <files>
    Berzerk/Source/Combat/ProjectileManager.cs
    Berzerk/Source/Combat/ImpactEffect.cs
  </files>
  <action>
Create ImpactEffect.cs:
- Namespace: Berzerk.Source.Combat
- Public class ImpactEffect with:
  - Position (Vector3)
  - IsActive (bool)
  - Private _lifetime = 0.2f (seconds)
  - Private _elapsed = 0f
  - Private _scale = 0.3f (initial size)
  - Scale property returns _scale * (1 - _elapsed/_lifetime) - shrinks over time
  - Alpha property returns 1 - _elapsed/_lifetime - fades out
  - Activate(Vector3 position) - sets position, resets elapsed, sets active
  - Update(float deltaTime) - increments elapsed, deactivates when elapsed >= lifetime

Modify ProjectileManager.cs to add:
- Private List<ImpactEffect> _activeEffects = new()
- Private Queue<ImpactEffect> _effectPool = new() (pool size 20)
- Private List<BoundingBox> _wallColliders (set via SetWallColliders)

Add SetWallColliders(List<BoundingBox> walls) method

Modify Update(float deltaTime) to:
1. Update projectiles as before
2. For each active projectile, check wall collision:
   - Get BoundingSphere from projectile
   - For each wall BoundingBox, if sphere.Intersects(wall):
     - Spawn impact effect at projectile.Transform.Position
     - Call projectile.OnHitWall()
     - Break inner loop
3. Update impact effects (iterate backwards, return inactive to pool)

Add SpawnImpactEffect(Vector3 position) private method - dequeue from pool or create new, activate, add to active list

Add GetActiveEffects() returns IReadOnlyList<ImpactEffect> for rendering

Note: Check collision BEFORE moving in Update, or check after move but before removing inactive. The research warns about tunneling but at 50 units/sec and 60fps, we move ~0.83 units/frame which is fine for arcade-style walls (typically 1+ unit thick).
  </action>
  <verify>
    dotnet build Berzerk/Berzerk.csproj
  </verify>
  <done>
    ProjectileManager checks wall collisions and spawns impact effects, ImpactEffect implements fade-out
  </done>
</task>

<task type="auto">
  <name>Task 3: Add impact effect rendering to ProjectileRenderer</name>
  <files>
    Berzerk/Source/Combat/ProjectileRenderer.cs
  </files>
  <action>
Extend ProjectileRenderer to draw impact effects:

Add DrawEffects(IReadOnlyList<ImpactEffect> effects, Matrix view, Matrix projection) method:
- For each active effect:
  - Set _effect.World = Matrix.CreateScale(effect.Scale) * Matrix.CreateTranslation(effect.Position)
  - Set _effect.EmissiveColor = new Vector3(1.0f, 0.8f, 0.3f) * effect.Alpha - orange/yellow fading
  - Draw same sphere mesh (reuse geometry)
  - Reset EmissiveColor to cyan after loop for next projectile draw

Alternative approach if performance matters: use same Draw call with color parameter, but for Phase 3 keeping it simple is fine.
  </action>
  <verify>
    dotnet build Berzerk/Berzerk.csproj
  </verify>
  <done>
    Impact effects render as fading orange spheres at collision points
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build Berzerk/Berzerk.csproj` succeeds
2. ProjectileRenderer.cs exists with sphere mesh and emissive BasicEffect
3. ImpactEffect.cs exists with fade-out logic
4. ProjectileManager has wall collision detection
</verification>

<success_criteria>
- Sphere mesh generates correctly with vertices and indices
- BasicEffect uses EmissiveColor for self-illuminated look
- Wall collision uses BoundingSphere.Intersects(BoundingBox)
- Impact effects spawn at collision points and fade out over 0.2 seconds
- All classes compile without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-core-combat-system/03-02-SUMMARY.md`
</output>
