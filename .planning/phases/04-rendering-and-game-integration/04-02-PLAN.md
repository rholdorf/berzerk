---
phase: 04-rendering-and-game-integration
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - Berzerk/Source/Enemies/EnemyRenderer.cs
  - Berzerk/Source/Enemies/EnemyController.cs
  - Berzerk/Source/Enemies/EnemyManager.cs
autonomous: true

must_haves:
  truths:
    - "EnemyRenderer loads ONE AnimatedModel with all animation clips merged, instead of three separate models"
    - "Each enemy has its own AnimatedModel instance with independent AnimationPlayer for independent animation timing"
    - "Switching enemy state (idle/chase/attack) calls PlayAnimation on that enemy's own AnimatedModel"
    - "Multiple enemies can play different animations simultaneously without interference"
  artifacts:
    - path: "Berzerk/Source/Enemies/EnemyRenderer.cs"
      provides: "Single shared model loading with merged clips, per-enemy AnimatedModel creation"
      contains: "AddAnimationsFrom"
    - path: "Berzerk/Source/Enemies/EnemyController.cs"
      provides: "Single AnimatedModel per enemy with PlayAnimation for state transitions"
      contains: "PlayAnimation"
  key_links:
    - from: "Berzerk/Source/Enemies/EnemyRenderer.cs"
      to: "AnimatedModel.AddAnimationsFrom"
      via: "LoadRobotModels loads one model and merges idle/walk/bash clips"
      pattern: "AddAnimationsFrom.*idle.*walk.*bash"
    - from: "Berzerk/Source/Enemies/EnemyController.cs"
      to: "AnimatedModel.PlayAnimation"
      via: "State transitions call PlayAnimation with clip name"
      pattern: "PlayAnimation.*(idle|walk|bash)"
    - from: "Berzerk/Source/Enemies/EnemyManager.cs"
      to: "EnemyRenderer"
      via: "Spawn creates per-enemy AnimatedModel via renderer factory method"
      pattern: "CreateEnemyModel|SetAnimatedModel"
---

<objective>
Refactor EnemyRenderer from loading 3 separate AnimatedModel instances (one per animation state) to loading one shared model with all clips merged. Give each enemy its own AnimatedModel for independent animation playback.

Purpose: The current approach triples GPU memory by loading the full character mesh 3 times. Since MonoGame's ContentManager caches Model instances, each enemy can load the same content path and get a shared GPU model reference. Each enemy gets its own AnimationPlayer (inside AnimatedModel) for independent playback timing. This fulfills GAME-02.

Output: EnemyRenderer.cs with single model loading pattern, EnemyController.cs with single AnimatedModel and PlayAnimation-based state transitions.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-rendering-and-game-integration/04-RESEARCH.md
@.planning/phases/04-rendering-and-game-integration/04-01-SUMMARY.md
@Berzerk/Source/Graphics/AnimatedModel.cs
@Berzerk/Source/Enemies/EnemyRenderer.cs
@Berzerk/Source/Enemies/EnemyController.cs
@Berzerk/Source/Enemies/EnemyManager.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor EnemyRenderer to load one shared model and provide per-enemy model factory</name>
  <files>Berzerk/Source/Enemies/EnemyRenderer.cs</files>
  <action>
**Replace three-model loading with single shared model:**

Change `LoadRobotModels` to load ONE AnimatedModel:
```csharp
private AnimatedModel? _sharedRobotModel;

public void LoadRobotModels(ContentManager content)
{
    _sharedRobotModel = new AnimatedModel();
    _sharedRobotModel.LoadContent(content, "Models/test-character");
    _sharedRobotModel.AddAnimationsFrom(content, "Models/idle", "idle");
    _sharedRobotModel.AddAnimationsFrom(content, "Models/walk", "walk");
    _sharedRobotModel.AddAnimationsFrom(content, "Models/bash", "bash");
    _sharedRobotModel.PlayAnimation("idle");
    Console.WriteLine("EnemyRenderer: Loaded shared robot model with merged animations");
}
```

Delete `_idleModel`, `_walkModel`, `_attackModel` fields.

**Add factory method for per-enemy model creation:**

Each enemy needs its own AnimatedModel instance so they animate independently. Since MonoGame's ContentManager caches the underlying Model object, calling `LoadContent` with the same path returns the cached GPU model -- no duplicate GPU memory. Each AnimatedModel creates its own AnimationPlayer.

```csharp
public AnimatedModel CreateEnemyModel(ContentManager content)
{
    var model = new AnimatedModel();
    model.LoadContent(content, "Models/test-character");
    model.AddAnimationsFrom(content, "Models/idle", "idle");
    model.AddAnimationsFrom(content, "Models/walk", "walk");
    model.AddAnimationsFrom(content, "Models/bash", "bash");
    model.PlayAnimation("idle");
    return model;
}
```

**Update GetSharedModels:**

Remove the old tuple-returning `GetSharedModels()` method. It is replaced by `CreateEnemyModel`.

Note: The `_sharedRobotModel` field is kept for potential future use (e.g., a reference/prototype) or can be removed if not needed. The key insight is that ContentManager handles GPU model caching -- we don't need to manually share a Model reference.

EnemyRenderer also needs a `ContentManager` reference to create models on demand during enemy spawning. Either:
- (a) Store `_content` in `LoadRobotModels` for later use by `CreateEnemyModel`
- (b) Pass ContentManager through the spawn call chain

Prefer (a): store `private ContentManager? _content;` in EnemyRenderer, set in `LoadRobotModels`.
  </action>
  <verify>
`dotnet build Berzerk/Berzerk.csproj` compiles. Grep for `_idleModel|_walkModel|_attackModel` in EnemyRenderer.cs returns nothing. Grep for `CreateEnemyModel` in EnemyRenderer.cs returns the factory method.
  </verify>
  <done>
EnemyRenderer loads one shared model with merged clips. Factory method `CreateEnemyModel` creates per-enemy AnimatedModel instances. Three separate model fields are gone.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor EnemyController to use single AnimatedModel with PlayAnimation</name>
  <files>Berzerk/Source/Enemies/EnemyController.cs, Berzerk/Source/Enemies/EnemyManager.cs</files>
  <action>
**EnemyController changes:**

Replace the three model fields (`_idleModel`, `_walkModel`, `_attackModel`) with a single `_animatedModel` field:

```csharp
private AnimatedModel? _animatedModel;
```

Update `SetAnimatedModels` to accept a single model:
```csharp
public void SetAnimatedModel(AnimatedModel? model)
{
    _animatedModel = model;
}
```

Update `CurrentModel` property:
```csharp
public AnimatedModel? CurrentModel => _animatedModel;
```

Update `SetCurrentModel` to call `PlayAnimation` with the clip name for the state:
```csharp
private void SetCurrentModel(EnemyState state)
{
    string? clipName = state switch
    {
        EnemyState.Idle => "idle",
        EnemyState.Chase => "walk",
        EnemyState.Attack => "bash",
        EnemyState.Dying => null, // Keep current animation during death
        _ => "idle"
    };

    if (clipName != null && _animatedModel != null)
    {
        _animatedModel.PlayAnimation(clipName);
    }
}
```

Update the `Update` method -- change `_currentModel?.Update(gameTime)` to `_animatedModel?.Update(gameTime)`.

Delete `_currentModel` field entirely.

**EnemyManager changes:**

Find the spawn code that calls `enemy.SetAnimatedModels(idle, walk, attack)` and change it to:
```csharp
var enemyModel = _enemyRenderer.CreateEnemyModel(content);
enemy.SetAnimatedModel(enemyModel);
```

EnemyManager needs access to ContentManager. Check if it already has it; if not, add a way to pass it (via constructor, or store from an initialization method). Look at how EnemyManager currently gets _enemyRenderer -- follow the same pattern for ContentManager.

The key change in EnemyManager: instead of `var (idle, walk, attack) = _enemyRenderer.GetSharedModels()`, call `_enemyRenderer.CreateEnemyModel(content)` to get a unique AnimatedModel per enemy.

**Important:** Each enemy MUST have its own AnimatedModel instance. If enemies share the same instance, all enemies will animate in sync (Research Pitfall 4). The factory method creates independent instances with independent AnimationPlayers.
  </action>
  <verify>
`dotnet build Berzerk/Berzerk.csproj` compiles with zero errors. Grep for `_idleModel|_walkModel|_attackModel` in EnemyController.cs returns nothing. Grep for `SetAnimatedModel` (singular) in EnemyController.cs returns the new method. Grep for `CreateEnemyModel` in EnemyManager.cs confirms it calls the factory. Run the game briefly -- enemies should render and animate (visual correctness verified Phase 5).
  </verify>
  <done>
EnemyController uses a single AnimatedModel with PlayAnimation-based state switching. EnemyManager creates per-enemy models via factory method. No shared animation state between enemies -- each has independent playback. Game compiles and runs.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Berzerk/Berzerk.csproj` compiles with zero errors
2. EnemyRenderer.cs has ONE model load path, not three (grep for `LoadContent.*test-character` returns 1 match in LoadRobotModels or CreateEnemyModel pattern)
3. EnemyController.cs has single `_animatedModel` field, not three separate fields
4. EnemyController state transitions use `PlayAnimation("idle"|"walk"|"bash")` not model swapping
5. EnemyManager creates per-enemy models via factory method
6. Game launches without crashes, enemies render
</verification>

<success_criteria>
- EnemyRenderer loads one shared model with all clips merged via AddAnimationsFrom
- Each enemy gets its own AnimatedModel instance via factory method (independent AnimationPlayer)
- State transitions call PlayAnimation with clip name instead of swapping model references
- No shared mutable animation state between enemies
- Game compiles and runs
</success_criteria>

<output>
After completion, create `.planning/phases/04-rendering-and-game-integration/04-02-SUMMARY.md`
</output>
