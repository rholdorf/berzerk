---
phase: 05-enemy-ai-combat
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - Berzerk/Source/Enemies/EnemyManager.cs
  - Berzerk/Source/Combat/TargetManager.cs
autonomous: true

must_haves:
  truths:
    - "Enemies spawn at safe distance from player"
    - "Enemies can be hit by projectiles and take damage"
    - "Destroyed enemies drop pickups with 35% chance"
    - "Enemy manager tracks active enemies and updates them"
  artifacts:
    - path: "Berzerk/Source/Enemies/EnemyManager.cs"
      provides: "Enemy spawning, pooling, and management"
      contains: "SpawnWave"
    - path: "Berzerk/Source/Combat/TargetManager.cs"
      provides: "Modified to handle health pickup pooling"
      contains: "HealthPickup"
  key_links:
    - from: "EnemyManager"
      to: "EnemyController"
      via: "object pooling"
      pattern: "Queue<EnemyController>"
    - from: "EnemyManager"
      to: "TargetManager"
      via: "pickup spawning"
      pattern: "SpawnHealthPickup|SpawnAmmoPickup"
---

<objective>
Create enemy manager for spawning, pooling, and projectile collision. Extend TargetManager to handle health pickups.

Purpose: Centralize enemy lifecycle management (spawn, update, destroy) and enable projectile-enemy collision detection. Drop system creates resource management gameplay.

Output: EnemyManager class ready for game integration. TargetManager extended with health pickup support.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enemy-ai-combat/05-CONTEXT.md
@.planning/phases/05-enemy-ai-combat/05-RESEARCH.md
@.planning/phases/05-enemy-ai-combat/05-01-SUMMARY.md

# Existing patterns to follow
@Berzerk/Source/Combat/TargetManager.cs
@Berzerk/Source/Combat/ProjectileManager.cs
@Berzerk/Source/Combat/AmmoPickup.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EnemyManager with spawning and pooling</name>
  <files>Berzerk/Source/Enemies/EnemyManager.cs</files>
  <action>
Create EnemyManager following TargetManager/ProjectileManager patterns:

**Pooling (per RESEARCH to prevent GC spikes):**
- `List<EnemyController> _enemies` - active enemies
- `Queue<EnemyController> _enemyPool` - pooled inactive enemies
- `Initialize(int poolSize = 20)` - pre-allocate pool
- Return inactive enemies to pool in Update

**Spawning:**
- `SpawnWave(int enemyCount, Vector3 playerPos)` - spawn wave of enemies
- `TryFindSpawnPosition(Vector3 playerPos, float minDistance, int maxAttempts = 20)` - returns Vector3?
- Minimum spawn distance = 10 units from player (per CONTEXT: spawn far for reaction time)
- Random position within room bounds (-10 to 10 on X/Z, Y = 0.5f)
- Check distance to existing enemies (min 3 units apart)
- Fallback to predefined safe zones if random fails (corners: -8,-8 / 8,-8 / -8,8 / 8,8)

**Update:**
- `Update(GameTime gameTime, Vector3 playerPos)` - update all active enemies
- Pass playerPos to each EnemyController.Update
- Return inactive enemies (IsActive = false) to pool

**Collision Detection:**
- `CheckProjectileCollisions(IReadOnlyList<Projectile> projectiles, int damagePerHit = 15)`
- BoundingSphere intersection (like TargetManager pattern)
- Call enemy.Health.TakeDamage on hit
- Deactivate projectile on hit (projectile.OnHitTarget pattern doesn't exist, use new OnHitEnemy or directly set inactive)

**Drop System (per CONTEXT: 30-40% chance):**
- `OnEnemyDeath` callback registered to each enemy's OnDeath event
- Random 35% chance to drop (middle of 30-40 range)
- 50/50 split between ammo and health pickup
- Store reference to TargetManager for spawning pickups
- `SetTargetManager(TargetManager tm)` to inject dependency

**State Queries:**
- `GetEnemies()` returns `IReadOnlyList<EnemyController>`
- `ActiveCount` property
- `AllEnemiesDefeated` property (useful for future room progression)

**Progressive Difficulty (Claude's discretion per CONTEXT):**
- `_currentWave` counter
- `GetWaveEnemyCount()` returns 2 + wave number (caps at 10)
- `StartNextWave(Vector3 playerPos)` - spawns next wave with scaling

Use `namespace Berzerk.Source.Enemies;`
  </action>
  <verify>
File compiles with `dotnet build Berzerk/Berzerk.csproj`
  </verify>
  <done>
EnemyManager spawns enemies at safe distances, pools them efficiently, and handles projectile collisions with drop spawning.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend TargetManager for health pickups</name>
  <files>Berzerk/Source/Combat/TargetManager.cs</files>
  <action>
Extend TargetManager to handle HealthPickup alongside existing AmmoPickup:

**Add fields:**
- `List<HealthPickup> _healthPickups`
- `Queue<HealthPickup> _healthPickupPool`

**Modify Initialize:**
- Pre-populate health pickup pool (size 10, like ammo)

**Modify Update:**
- Update all active health pickups (bobbing animation)
- Return inactive health pickups to pool

**Add SpawnHealthPickup(Vector3 position):**
- Mirror existing SpawnPickup pattern (renamed to SpawnAmmoPickup for clarity)
- Get from pool or create new
- Add to active list

**Rename internal pickup method:**
- Rename `SpawnPickup` to `SpawnAmmoPickup` (make public for EnemyManager access)
- Keep existing behavior

**Modify CheckPickupCollection:**
- Also check health pickups
- Call `_healthSystem.Heal(amount)` for health pickups (need HealthSystem param or modify signature)
- Update signature: `CheckPickupCollection(Vector3 playerPos, AmmoSystem ammo, HealthSystem health)`

**Add GetHealthPickups():**
- Return `IReadOnlyList<HealthPickup>` for rendering
  </action>
  <verify>
File compiles. Health pickup collection integrates with existing system.
  </verify>
  <done>
TargetManager handles both ammo and health pickups with pooling and collection.
  </done>
</task>

</tasks>

<verification>
1. Both files compile: `dotnet build Berzerk/Berzerk.csproj`
2. EnemyManager.SpawnWave creates enemies at valid positions
3. EnemyManager.CheckProjectileCollisions processes hits
4. TargetManager.SpawnHealthPickup works
5. TargetManager.CheckPickupCollection heals player for health pickups
</verification>

<success_criteria>
- Enemy spawning respects minimum distance from player
- Projectile-enemy collision damages enemies correctly
- Drop system spawns pickups on enemy death
- Health pickups heal player when collected
- Object pooling prevents GC spikes
</success_criteria>

<output>
After completion, create `.planning/phases/05-enemy-ai-combat/05-02-SUMMARY.md`
</output>
