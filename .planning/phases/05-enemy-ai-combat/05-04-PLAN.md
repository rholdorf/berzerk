---
phase: 05-enemy-ai-combat
plan: 04
type: execute
wave: 3
depends_on: ["05-02", "05-03"]
files_modified:
  - Berzerk/BerzerkGame.cs
  - Berzerk/Source/Controllers/PlayerController.cs
  - Berzerk/Source/Enemies/EnemyManager.cs
autonomous: true

must_haves:
  truths:
    - "Enemies spawn when game starts and player can shoot them"
    - "Player takes damage and knockback when enemy attacks"
    - "Enemies drop pickups when destroyed"
    - "Player can collect health pickups to heal"
    - "All enemies defeated is tracked for future progression"
  artifacts:
    - path: "Berzerk/BerzerkGame.cs"
      provides: "Full enemy system integration"
      contains: "_enemyManager"
    - path: "Berzerk/Source/Controllers/PlayerController.cs"
      provides: "Knockback velocity support"
      contains: "ApplyKnockback"
  key_links:
    - from: "BerzerkGame"
      to: "EnemyManager"
      via: "game loop integration"
      pattern: "_enemyManager.Update"
    - from: "EnemyController"
      to: "PlayerController"
      via: "knockback on attack"
      pattern: "ApplyKnockback"
---

<objective>
Integrate enemy system into the game: wire EnemyManager, add player knockback, connect all systems, and verify combat loop.

Purpose: Complete the enemy AI & combat phase by connecting all components. Player can now fight actual enemies that spawn, chase, attack, and drop resources.

Output: Fully playable enemy combat with spawning, AI behavior, damage dealing, destruction, and pickup drops.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enemy-ai-combat/05-CONTEXT.md
@.planning/phases/05-enemy-ai-combat/05-RESEARCH.md
@.planning/phases/05-enemy-ai-combat/05-01-SUMMARY.md
@.planning/phases/05-enemy-ai-combat/05-02-SUMMARY.md
@.planning/phases/05-enemy-ai-combat/05-03-SUMMARY.md

# Files to integrate
@Berzerk/BerzerkGame.cs
@Berzerk/Source/Controllers/PlayerController.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add knockback support to PlayerController</name>
  <files>Berzerk/Source/Controllers/PlayerController.cs</files>
  <action>
Add knockback mechanics (per CONTEXT: light knockback maintains impact feel):

**Add fields:**
- `private Vector3 _knockbackVelocity = Vector3.Zero`
- `private const float KnockbackDecay = 10f` (how fast knockback fades)

**Add ApplyKnockback method:**
```csharp
public void ApplyKnockback(Vector3 direction, float force)
{
    // Ensure horizontal knockback only
    direction.Y = 0;
    if (direction.LengthSquared() > 0)
    {
        _knockbackVelocity += Vector3.Normalize(direction) * force;
    }
}
```

**Modify Update method:**
After IsEnabled check, before normal movement:
- Apply knockback velocity to position: `Transform.Position += _knockbackVelocity * deltaTime`
- Decay knockback: `_knockbackVelocity *= (float)Math.Pow(0.01, deltaTime * KnockbackDecay / 0.4)`
  (exponential decay pattern from DamageVignette)
- Clear tiny values: if LengthSquared < 0.01f, set to Zero

This ensures knockback is applied even during normal movement, creating the pushed-back feel.
  </action>
  <verify>
File compiles. ApplyKnockback method exists.
  </verify>
  <done>
PlayerController supports knockback velocity that decays over time.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire enemy attack to deal damage with knockback</name>
  <files>Berzerk/Source/Enemies/EnemyController.cs</files>
  <action>
Modify EnemyController to deal damage and apply knockback:

**Add attack callback:**
- Add `public Action<int, Vector3>? OnAttackPlayer` event
  - Parameters: damage amount, knockback direction (from enemy to player)

**Modify UpdateAttackState:**
When attack cooldown ready and in range:
1. Invoke OnAttackPlayer with ATTACK_DAMAGE (10) and direction to player
2. Reset cooldown

This decouples the damage/knockback application from the enemy (BerzerkGame will wire it to HealthSystem and PlayerController).
  </action>
  <verify>
File compiles. OnAttackPlayer event exists.
  </verify>
  <done>
EnemyController fires attack event that game can wire to player damage and knockback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate enemy system into BerzerkGame</name>
  <files>Berzerk/BerzerkGame.cs</files>
  <action>
Complete integration of all enemy systems:

**Add fields:**
- `private EnemyManager _enemyManager`
- `private EnemyRenderer _enemyRenderer`

**Add using statements:**
- `using Berzerk.Source.Enemies;`

**Initialize (in Initialize method):**
- Create `_enemyManager = new EnemyManager()`
- Call `_enemyManager.Initialize(20)` for pool
- Call `_enemyManager.SetTargetManager(_targetManager)` for pickup drops

**LoadContent:**
- Create `_enemyRenderer = new EnemyRenderer(GraphicsDevice)`
- Spawn initial wave: `_enemyManager.SpawnWave(3, _playerController.Transform.Position)`
  (start with 3 enemies per CONTEXT: 2-3 robots initially)

**Wire enemy attacks to player damage:**
After spawning, for each enemy in manager, subscribe to OnAttackPlayer:
Create helper method `WireEnemyEvents(EnemyController enemy)`:
```csharp
enemy.OnAttackPlayer += (damage, direction) =>
{
    if (_gameState != GameState.Playing) return;
    _healthSystem.TakeDamage(damage);
    _playerController.ApplyKnockback(direction, 8f); // knockback force
    Console.WriteLine($"Enemy attacked! -{damage} HP");
};
```

Call this in EnemyManager when activating enemies (add SetAttackCallback or similar).

**Update (in UpdatePlaying):**
- Update enemies: `_enemyManager.Update(gameTime, _playerController.Transform.Position)`
- Check projectile collisions: `_enemyManager.CheckProjectileCollisions(_projectileManager.GetActiveProjectiles())`
- Modify TargetManager.CheckPickupCollection call to include _healthSystem

**Draw:**
- Draw enemies: `_enemyRenderer.DrawEnemies(_enemyManager.GetEnemies(), _camera.ViewMatrix, _camera.ProjectionMatrix)`
- Draw explosions: `_enemyRenderer.DrawExplosions(_enemyManager.GetActiveExplosions(), _camera.ViewMatrix, _camera.ProjectionMatrix)`
- Draw health pickups: `_enemyRenderer.DrawHealthPickups(_targetManager.GetHealthPickups(), _camera.ViewMatrix, _camera.ProjectionMatrix)`

**RestartGame:**
- Reset enemy manager (clear enemies, reset wave counter)
- Spawn fresh wave

**Console output:**
- Print wave info on spawn
- Print when enemy destroyed
- Print when pickup dropped

**Test key (optional):**
- Keep H for test damage
- Add G key to spawn new enemy wave for testing
  </action>
  <verify>
Game compiles and runs. Enemies spawn and can be seen.
  </verify>
  <done>
Enemy system fully integrated: spawn, chase, attack with knockback, destruction with drops, health pickup healing.
  </done>
</task>

</tasks>

<verification>
Manual testing checklist:
1. `dotnet run --project Berzerk/Berzerk.csproj`
2. Game starts with 3 enemies visible (red cubes)
3. Enemies move toward player when in range
4. Player can shoot enemies (takes 2-3 hits to destroy)
5. Enemies deal 10 damage when in melee range
6. Player gets knocked back when hit
7. Destroyed enemies show explosion effect
8. ~35% of enemies drop pickup (green health or yellow ammo)
9. Health pickups heal player when collected
10. R key restarts with fresh enemies
11. G key (if added) spawns new wave
</verification>

<success_criteria>
- Complete combat loop: spawn -> detect -> chase -> attack -> destroy
- Knockback provides impact feedback
- Drop system creates resource management
- All Phase 5 requirements (AI-01 through AI-06, ANIM-05 through ANIM-08 placeholders) met
- Game remains playable without crashes
</success_criteria>

<output>
After completion, create `.planning/phases/05-enemy-ai-combat/05-04-SUMMARY.md`
</output>
