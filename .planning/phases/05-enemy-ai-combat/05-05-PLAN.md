---
phase: 05-enemy-ai-combat
plan: 05
type: execute
wave: 1
depends_on: ["05-04"]
files_modified:
  - .planning/ROADMAP.md
  - .planning/REQUIREMENTS.md
  - Berzerk/BerzerkGame.cs
  - Berzerk/Source/Enemies/EnemyRenderer.cs
  - Berzerk/Source/Enemies/EnemyController.cs
  - Berzerk/Source/Enemies/EnemyManager.cs
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "Robot enemies render using AnimatedModel instead of placeholder cubes"
    - "Enemy walk animation plays when enemy is chasing player"
    - "Enemy attack animation plays when enemy is in attack state"
    - "ROADMAP reflects direct movement decision (no pathfinding requirement)"
  artifacts:
    - path: "Berzerk/Source/Enemies/EnemyRenderer.cs"
      provides: "AnimatedModel rendering for enemies"
      contains: "DrawAnimatedEnemy"
    - path: "Berzerk/Source/Enemies/EnemyController.cs"
      provides: "Animation state transitions"
      contains: "PlayAnimation"
    - path: ".planning/ROADMAP.md"
      provides: "Updated success criteria"
      contains: "direct movement"
  key_links:
    - from: "EnemyController"
      to: "AnimatedModel"
      via: "state machine"
      pattern: "_animatedModel.PlayAnimation"
    - from: "EnemyRenderer"
      to: "AnimatedModel"
      via: "draw method"
      pattern: "_enemyModel.Draw"
---

<objective>
Close verification gaps: Add animated robot models to enemies, wire animation state transitions, and update ROADMAP to reflect design decisions.

Purpose: Phase 5 verification found that enemies render as placeholder cubes instead of Mixamo models, and animations are not wired to state transitions. This plan closes those gaps while updating documentation to reflect the direct movement decision (pathfinding was Claude's discretion per CONTEXT).

Output: Enemies render with animated Mixamo robot model, animations transition with states, ROADMAP accurately describes implemented behavior.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enemy-ai-combat/05-CONTEXT.md
@.planning/phases/05-enemy-ai-combat/05-VERIFICATION.md
@.planning/phases/05-enemy-ai-combat/05-04-SUMMARY.md

# Files to modify
@Berzerk/Source/Enemies/EnemyRenderer.cs
@Berzerk/Source/Enemies/EnemyController.cs
@Berzerk/Source/Enemies/EnemyManager.cs
@Berzerk/BerzerkGame.cs
@Berzerk/Source/Graphics/AnimatedModel.cs
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <action>Download robot model from Mixamo</action>
  <instructions>
The game needs a robot enemy model with animations. Please:

1. Go to https://www.mixamo.com (Adobe account required)
2. Search for a robot character (e.g., "X Bot" or any robot-like character)
3. Download the character with these animations:
   - **Idle** (any idle animation)
   - **Walk** or **Run Forward** (for chase state)
   - **Punch** or **Melee Attack** (for attack state)

4. Export settings for EACH animation:
   - Format: **FBX Binary (.fbx)**
   - Skin: **With Skin**
   - Frames per Second: **30**
   - Keyframe Reduction: **none**

5. Save files to `Berzerk/Content/Models/`:
   - `robot-idle.fbx` (robot with idle animation)
   - `robot-walk.fbx` (robot with walk/run animation)
   - `robot-attack.fbx` (robot with attack animation)

6. Add to Content.mgcb (via MGCB Editor or manually):
   ```
   /importer:FbxImporter
   /processor:FbxAnimationProcessor
   /build:Models/robot-idle.fbx
   /build:Models/robot-walk.fbx
   /build:Models/robot-attack.fbx
   ```

NOTE: If you don't have a Mixamo account or want to skip this, type "skip" and enemies will continue using placeholder cubes. The animation wiring will still be implemented but won't be visible until models are added.
  </instructions>
  <resume-signal>Type "done" when robot models are added, or "skip" to proceed with placeholder cubes</resume-signal>
</task>

<task type="auto">
  <name>Task 1: Update ROADMAP to reflect direct movement decision</name>
  <files>.planning/ROADMAP.md, .planning/REQUIREMENTS.md</files>
  <action>
Update documentation to reflect the design decision made per CONTEXT.md:

**In ROADMAP.md, Phase 5 Success Criteria #3:**
Change:
```
3. Robots navigate toward player using pathfinding (not straight-line)
```
To:
```
3. Robots navigate toward player (direct movement per CONTEXT - pathfinding not required for single-room arcade)
```

**In ROADMAP.md, Phase 5 Success Criteria #6:**
Change:
```
6. Destroyed robots play death animation, disappear, and award score points
```
To:
```
6. Destroyed robots play death animation and disappear (score points deferred per CONTEXT)
```

**In REQUIREMENTS.md AI-03:**
Add note that direct movement is acceptable:
```
- [ ] **AI-03**: Robots navigate toward player (direct movement acceptable for single-room)
```

**In REQUIREMENTS.md AI-06:**
Update to reflect scope:
```
- [ ] **AI-06**: Destroyed robots disappear (score points deferred to Phase 7 UI)
```

This aligns documentation with the actual decisions made during Phase 5 discussion.
  </action>
  <verify>
grep -q "direct movement" .planning/ROADMAP.md
  </verify>
  <done>
ROADMAP and REQUIREMENTS reflect that direct movement was a valid design choice, and score is deferred.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AnimatedModel support to EnemyController</name>
  <files>Berzerk/Source/Enemies/EnemyController.cs</files>
  <action>
Add animation integration to EnemyController:

**Add using statement:**
```csharp
using Berzerk.Graphics;
```

**Add field:**
```csharp
private AnimatedModel? _animatedModel;
```

**Add setter method:**
```csharp
/// <summary>
/// Set the animated model for this enemy.
/// Called by EnemyManager after activation.
/// </summary>
public void SetAnimatedModel(AnimatedModel model)
{
    _animatedModel = model;
}

/// <summary>
/// Get the animated model (for rendering).
/// </summary>
public AnimatedModel? AnimatedModel => _animatedModel;
```

**Modify OnStateEnter to trigger animations:**
```csharp
private void OnStateEnter(EnemyState state)
{
    switch (state)
    {
        case EnemyState.Idle:
            _animatedModel?.PlayAnimation("idle");
            break;

        case EnemyState.Chase:
            _animatedModel?.PlayAnimation("walk");
            break;

        case EnemyState.Attack:
            _attackTimer = 0f; // Reset cooldown on entering attack state
            _animatedModel?.PlayAnimation("attack");
            break;

        case EnemyState.Dying:
            _deathTimer = 0f;
            _velocity = Vector3.Zero;
            // No death animation - explosion effect handles visual
            break;
    }
}
```

**Add Update call for animation:**
At the end of the Update method (after state switch), add:
```csharp
// Update animation
_animatedModel?.Update(gameTime);
```

This wires the FSM states to animation playback. Animation names match Mixamo defaults: "idle", "walk", "attack".
  </action>
  <verify>
grep -q "PlayAnimation" Berzerk/Source/Enemies/EnemyController.cs
  </verify>
  <done>
EnemyController triggers animations on state transitions (idle/walk/attack).
  </done>
</task>

<task type="auto">
  <name>Task 3: Add AnimatedModel rendering to EnemyRenderer</name>
  <files>Berzerk/Source/Enemies/EnemyRenderer.cs</files>
  <action>
Modify EnemyRenderer to render animated models when available:

**Add using statement:**
```csharp
using Berzerk.Graphics;
```

**Add model fields:**
```csharp
private AnimatedModel? _robotIdleModel;
private AnimatedModel? _robotWalkModel;
private AnimatedModel? _robotAttackModel;
private bool _modelsLoaded = false;
```

**Add LoadRobotModels method:**
```csharp
/// <summary>
/// Load robot models from content. Call from BerzerkGame.LoadContent.
/// </summary>
public void LoadRobotModels(ContentManager content)
{
    try
    {
        _robotIdleModel = new AnimatedModel();
        _robotIdleModel.LoadContent(content, "Models/robot-idle");

        _robotWalkModel = new AnimatedModel();
        _robotWalkModel.LoadContent(content, "Models/robot-walk");

        _robotAttackModel = new AnimatedModel();
        _robotAttackModel.LoadContent(content, "Models/robot-attack");

        _modelsLoaded = true;
        Console.WriteLine("EnemyRenderer: Robot models loaded successfully");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"EnemyRenderer: Robot models not found, using placeholder cubes. ({ex.Message})");
        _modelsLoaded = false;
    }
}

/// <summary>
/// Get the appropriate model for the enemy's current state.
/// </summary>
public AnimatedModel? GetModelForState(EnemyState state)
{
    if (!_modelsLoaded) return null;

    return state switch
    {
        EnemyState.Idle => _robotIdleModel,
        EnemyState.Chase => _robotWalkModel,
        EnemyState.Attack => _robotAttackModel,
        _ => _robotIdleModel
    };
}
```

**Add using for ContentManager:**
```csharp
using Microsoft.Xna.Framework.Content;
```

**Modify DrawEnemies method:**
```csharp
public void DrawEnemies(IReadOnlyList<EnemyController> enemies, Matrix view, Matrix projection)
{
    foreach (var enemy in enemies)
    {
        if (!enemy.IsActive) continue;

        // Try to use animated model if available
        if (enemy.AnimatedModel != null)
        {
            // Scale and rotate like player model (Mixamo convention)
            Matrix modelScale = Matrix.CreateScale(0.01f);
            Matrix modelRotationCorrection = Matrix.CreateRotationY(MathHelper.Pi);
            Matrix worldMatrix = modelScale * modelRotationCorrection * enemy.Transform.WorldMatrix;

            enemy.AnimatedModel.Draw(_graphicsDevice, worldMatrix, view, projection);
        }
        else
        {
            // Fallback to colored cube placeholder
            Color stateColor = enemy.Health.IsDead ? Color.Gray : Color.Red;
            DrawCube(enemy.Transform.Position, 1.0f, stateColor, view, projection);
        }
    }
}
```

This allows gradual adoption: enemies with models render animated, others use cubes.
  </action>
  <verify>
grep -q "LoadRobotModels" Berzerk/Source/Enemies/EnemyRenderer.cs
  </verify>
  <done>
EnemyRenderer can render animated robot models with fallback to placeholder cubes.
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire animated models in EnemyManager and BerzerkGame</name>
  <files>Berzerk/Source/Enemies/EnemyManager.cs, Berzerk/BerzerkGame.cs</files>
  <action>
Complete the wiring between enemy system and animated models:

**In EnemyManager.cs:**

Add reference to EnemyRenderer:
```csharp
private EnemyRenderer? _enemyRenderer;

/// <summary>
/// Set the renderer for model assignment.
/// </summary>
public void SetEnemyRenderer(EnemyRenderer renderer)
{
    _enemyRenderer = renderer;
}
```

Modify SpawnEnemy (or wherever enemy is activated) to assign model:
```csharp
// After activating enemy from pool, assign animated model based on initial state
if (_enemyRenderer != null)
{
    var model = _enemyRenderer.GetModelForState(EnemyState.Idle);
    if (model != null)
    {
        enemy.SetAnimatedModel(model);
    }
}
```

**In BerzerkGame.cs:**

In LoadContent, after creating EnemyRenderer:
```csharp
_enemyRenderer = new EnemyRenderer(GraphicsDevice);
_enemyRenderer.LoadRobotModels(Content);  // Add this line
_enemyManager.SetEnemyRenderer(_enemyRenderer);  // Add this line
```

This completes the wiring:
- BerzerkGame loads robot models into EnemyRenderer
- EnemyManager gets reference to EnemyRenderer
- When enemies spawn, they get assigned the appropriate AnimatedModel
- EnemyController updates and triggers animations based on state
- EnemyRenderer draws animated models (or fallback cubes)
  </action>
  <verify>
grep -q "LoadRobotModels" Berzerk/BerzerkGame.cs
grep -q "SetEnemyRenderer" Berzerk/Source/Enemies/EnemyManager.cs
  </verify>
  <done>
Enemy animation system fully wired: models load, enemies get assigned models, animations play based on state.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `dotnet build Berzerk/Berzerk.csproj` - Must compile without errors
2. `dotnet run --project Berzerk/Berzerk.csproj` - Game runs
3. If robot models were added:
   - Enemies render as animated robot models (not cubes)
   - Walk animation plays when enemies chase
   - Attack animation plays when enemies attack
4. If models skipped:
   - Enemies render as red cubes (placeholder)
   - Console shows "Robot models not found, using placeholder cubes"
   - Animation wiring exists, ready for models to be added later
5. Check ROADMAP.md has "direct movement" text
6. Check REQUIREMENTS.md has updated AI-03 and AI-06

Key verification: Even without robot models, the animation system is wired and ready.
</verification>

<success_criteria>
- EnemyController has animation wiring (PlayAnimation calls in OnStateEnter)
- EnemyRenderer supports both AnimatedModel and placeholder cube rendering
- EnemyManager assigns models to enemies on spawn
- BerzerkGame loads robot models (gracefully handles missing)
- ROADMAP updated to reflect direct movement decision
- REQUIREMENTS updated to reflect scope (no pathfinding requirement, score deferred)
- Game compiles and runs without crashes
</success_criteria>

<output>
After completion, create `.planning/phases/05-enemy-ai-combat/05-05-SUMMARY.md`
</output>
