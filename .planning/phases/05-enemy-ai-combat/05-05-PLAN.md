---
phase: 05-enemy-ai-combat
plan: 05
type: execute
wave: 4
depends_on: ["05-04"]
files_modified:
  - .planning/ROADMAP.md
  - .planning/REQUIREMENTS.md
  - Berzerk/BerzerkGame.cs
  - Berzerk/Source/Enemies/EnemyRenderer.cs
  - Berzerk/Source/Enemies/EnemyController.cs
  - Berzerk/Source/Enemies/EnemyManager.cs
autonomous: false
gap_closure: true

must_haves:
  truths:
    - "Robot enemies render using AnimatedModel instead of placeholder cubes"
    - "Enemy walk animation plays when enemy is chasing player"
    - "Enemy attack animation plays when enemy is in attack state"
  artifacts:
    - path: "Berzerk/Source/Enemies/EnemyRenderer.cs"
      provides: "AnimatedModel loading and shared models for enemies"
      contains: "LoadRobotModels"
    - path: "Berzerk/Source/Enemies/EnemyController.cs"
      provides: "Animation switching on state transitions"
      contains: "SetCurrentModel"
    - path: "Berzerk/Source/Enemies/EnemyManager.cs"
      provides: "Model assignment to enemies on spawn"
      contains: "SetEnemyRenderer"
  key_links:
    - from: "EnemyController"
      to: "AnimatedModel"
      via: "state machine"
      pattern: "_currentModel = _animatedModels"
    - from: "EnemyRenderer"
      to: "AnimatedModel"
      via: "draw method"
      pattern: "_currentModel.Draw"
---

<objective>
Close verification gaps: Add animated robot models to enemies, wire animation state transitions, and update ROADMAP to reflect design decisions.

Purpose: Phase 5 verification found that enemies render as placeholder cubes instead of Mixamo models, and animations are not wired to state transitions. This plan closes those gaps while updating documentation to reflect the direct movement decision (pathfinding was Claude's discretion).

Output: Enemies render with animated Mixamo robot model, animations transition with states, ROADMAP accurately describes implemented behavior.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enemy-ai-combat/05-CONTEXT.md
@.planning/phases/05-enemy-ai-combat/05-VERIFICATION.md
@.planning/phases/05-enemy-ai-combat/05-04-SUMMARY.md

# Files to modify
@Berzerk/Source/Enemies/EnemyRenderer.cs
@Berzerk/Source/Enemies/EnemyController.cs
@Berzerk/Source/Enemies/EnemyManager.cs
@Berzerk/BerzerkGame.cs

# Pattern reference - how player handles multiple animations
@Berzerk/Source/Graphics/AnimatedModel.cs
</context>

<tasks>

<task type="checkpoint:human-action" gate="blocking">
  <action>Download robot model from Mixamo</action>
  <instructions>
The game needs a robot enemy model with animations. Following the same pattern as the player model (separate FBX files with same character, different animations):

1. Go to https://www.mixamo.com (Adobe account required)
2. Search for a robot character (e.g., "X Bot" or any robot-like character)
3. Download THREE separate FBX files (same character with different animations):

   **File 1: robot-idle.fbx**
   - Select the robot character
   - Choose any idle animation
   - Export: FBX Binary, With Skin, 30 FPS, Keyframe Reduction: none

   **File 2: robot-walk.fbx**
   - Same robot character
   - Choose a walk/run animation (e.g., "Walking" or "Run Forward")
   - Export: FBX Binary, With Skin, 30 FPS, Keyframe Reduction: none

   **File 3: robot-attack.fbx**
   - Same robot character
   - Choose a melee attack animation (e.g., "Punch" or "Melee Attack")
   - Export: FBX Binary, With Skin, 30 FPS, Keyframe Reduction: none

4. Save all three files to `Berzerk/Content/Models/`:
   - `robot-idle.fbx`
   - `robot-walk.fbx`
   - `robot-attack.fbx`

5. Add to Content.mgcb (via MGCB Editor or manually):
   ```
   /importer:FbxImporter
   /processor:FbxAnimationProcessor
   /build:Models/robot-idle.fbx
   /build:Models/robot-walk.fbx
   /build:Models/robot-attack.fbx
   ```

NOTE: This follows the exact same pattern as the player model (idle.fbx, walk.fbx, run.fbx). Each FBX contains the same character mesh with a different animation baked in.

If you don't have a Mixamo account or want to skip this, type "skip" and enemies will continue using placeholder cubes. The animation wiring will still be implemented but won't be visible until models are added.
  </instructions>
  <resume-signal>Type "done" when robot models are added, or "skip" to proceed with placeholder cubes</resume-signal>
</task>

<task type="auto">
  <name>Task 1: Update ROADMAP to reflect direct movement decision</name>
  <files>.planning/ROADMAP.md, .planning/REQUIREMENTS.md</files>
  <action>
Update documentation to reflect the design decision made (pathfinding was Claude's discretion, not a locked user decision):

**In ROADMAP.md, Phase 5 Success Criteria #3:**
Change:
```
3. Robots navigate toward player using pathfinding (not straight-line)
```
To:
```
3. Robots navigate toward player (direct movement chosen per Claude's discretion - pathfinding not required for single-room arcade)
```

**In ROADMAP.md, Phase 5 Success Criteria #6:**
Change:
```
6. Destroyed robots play death animation, disappear, and award score points
```
To:
```
6. Destroyed robots play death animation and disappear (score points deferred per CONTEXT)
```

**In REQUIREMENTS.md AI-03:**
Add note that direct movement is acceptable:
```
- [ ] **AI-03**: Robots navigate toward player (direct movement acceptable for single-room)
```

**In REQUIREMENTS.md AI-06:**
Update to reflect scope:
```
- [ ] **AI-06**: Destroyed robots disappear (score points deferred to Phase 7 UI)
```

This aligns documentation with the actual decisions made during Phase 5 discussion.
  </action>
  <verify>
grep -q "direct movement" .planning/ROADMAP.md
  </verify>
  <done>
ROADMAP and REQUIREMENTS reflect that direct movement was a valid design choice per Claude's discretion, and score is deferred.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add AnimatedModel support to EnemyController (model switching pattern)</name>
  <files>Berzerk/Source/Enemies/EnemyController.cs</files>
  <action>
Add animation integration to EnemyController following the player's model-switching pattern (where each animation is a separate AnimatedModel instance that gets swapped on state change):

**Add using statement:**
```csharp
using Berzerk.Graphics;
```

**Add fields for all animation models:**
```csharp
// Animated model references (shared instances from EnemyRenderer)
private AnimatedModel? _idleModel;
private AnimatedModel? _walkModel;
private AnimatedModel? _attackModel;
private AnimatedModel? _currentModel;
```

**Add setter method to receive all models:**
```csharp
/// <summary>
/// Set the animated models for this enemy (shared instances from EnemyRenderer).
/// Each model contains one animation for a specific state.
/// </summary>
public void SetAnimatedModels(AnimatedModel? idle, AnimatedModel? walk, AnimatedModel? attack)
{
    _idleModel = idle;
    _walkModel = walk;
    _attackModel = attack;
    _currentModel = idle; // Start with idle
}

/// <summary>
/// Get the current animated model (for rendering).
/// </summary>
public AnimatedModel? CurrentModel => _currentModel;
```

**Add helper to switch current model based on state:**
```csharp
/// <summary>
/// Switch to the appropriate model for the given state.
/// Follows player pattern: each state has its own AnimatedModel instance.
/// </summary>
private void SetCurrentModel(EnemyState state)
{
    AnimatedModel? targetModel = state switch
    {
        EnemyState.Idle => _idleModel,
        EnemyState.Chase => _walkModel,
        EnemyState.Attack => _attackModel,
        EnemyState.Dying => _currentModel, // Keep current during death
        _ => _idleModel
    };

    if (targetModel != null && targetModel != _currentModel)
    {
        _currentModel = targetModel;
        // Play the first animation in this model (each FBX has one animation)
        var animNames = _currentModel.GetAnimationNames();
        if (animNames.Count > 0)
        {
            _currentModel.PlayAnimation(animNames[0]);
        }
    }
}
```

**Modify OnStateEnter to switch models:**
```csharp
private void OnStateEnter(EnemyState state)
{
    // Switch animated model based on state (like player's animation switching)
    SetCurrentModel(state);

    switch (state)
    {
        case EnemyState.Attack:
            _attackTimer = 0f; // Reset cooldown on entering attack state
            break;

        case EnemyState.Dying:
            _deathTimer = 0f;
            _velocity = Vector3.Zero;
            // No death animation - explosion effect handles visual
            break;
    }
}
```

**Add Update call for animation at end of Update method:**
After the state switch block, add:
```csharp
// Update current animation
_currentModel?.Update(gameTime);
```

This wires the FSM states to model switching, following the same pattern the player uses.
  </action>
  <verify>
grep -q "SetCurrentModel" Berzerk/Source/Enemies/EnemyController.cs
grep -q "SetAnimatedModels" Berzerk/Source/Enemies/EnemyController.cs
  </verify>
  <done>
EnemyController switches between AnimatedModel instances on state transitions (idle/walk/attack), following player pattern.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add shared AnimatedModel loading to EnemyRenderer</name>
  <files>Berzerk/Source/Enemies/EnemyRenderer.cs</files>
  <action>
Modify EnemyRenderer to load shared AnimatedModel instances (one set for all enemies to reference):

**Add using statements:**
```csharp
using Berzerk.Graphics;
using Microsoft.Xna.Framework.Content;
```

**Add shared model fields:**
```csharp
// Shared robot models (all enemies reference these same instances)
private AnimatedModel? _robotIdleModel;
private AnimatedModel? _robotWalkModel;
private AnimatedModel? _robotAttackModel;
private bool _modelsLoaded = false;
```

**Add LoadRobotModels method:**
```csharp
/// <summary>
/// Load shared robot models from content. Call from BerzerkGame.LoadContent.
/// Each FBX contains the same robot character with a different animation.
/// </summary>
public void LoadRobotModels(ContentManager content)
{
    try
    {
        _robotIdleModel = new AnimatedModel();
        _robotIdleModel.LoadContent(content, "Models/robot-idle");

        _robotWalkModel = new AnimatedModel();
        _robotWalkModel.LoadContent(content, "Models/robot-walk");

        _robotAttackModel = new AnimatedModel();
        _robotAttackModel.LoadContent(content, "Models/robot-attack");

        _modelsLoaded = true;
        Console.WriteLine("EnemyRenderer: Robot models loaded successfully");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"EnemyRenderer: Robot models not found, using placeholder cubes. ({ex.Message})");
        _modelsLoaded = false;
    }
}

/// <summary>
/// Get the shared model references for assigning to enemies.
/// Returns (idle, walk, attack) tuple - may be null if models not loaded.
/// </summary>
public (AnimatedModel? idle, AnimatedModel? walk, AnimatedModel? attack) GetSharedModels()
{
    return (_robotIdleModel, _robotWalkModel, _robotAttackModel);
}

/// <summary>
/// Check if robot models are loaded.
/// </summary>
public bool HasModels => _modelsLoaded;
```

**Modify DrawEnemies method to use CurrentModel:**
```csharp
public void DrawEnemies(IReadOnlyList<EnemyController> enemies, Matrix view, Matrix projection)
{
    foreach (var enemy in enemies)
    {
        if (!enemy.IsActive) continue;

        // Try to use animated model if available
        if (enemy.CurrentModel != null)
        {
            // Scale and rotate like player model (Mixamo convention)
            Matrix modelScale = Matrix.CreateScale(0.01f);
            Matrix modelRotationCorrection = Matrix.CreateRotationY(MathHelper.Pi);
            Matrix worldMatrix = modelScale * modelRotationCorrection * enemy.Transform.WorldMatrix;

            enemy.CurrentModel.Draw(_graphicsDevice, worldMatrix, view, projection);
        }
        else
        {
            // Fallback to colored cube placeholder
            Color stateColor = enemy.Health.IsDead ? Color.Gray : Color.Red;
            DrawCube(enemy.Transform.Position, 1.0f, stateColor, view, projection);
        }
    }
}
```

This creates a single set of shared AnimatedModel instances that all enemies reference. Each enemy switches between these shared models on state change.
  </action>
  <verify>
grep -q "LoadRobotModels" Berzerk/Source/Enemies/EnemyRenderer.cs
grep -q "GetSharedModels" Berzerk/Source/Enemies/EnemyRenderer.cs
  </verify>
  <done>
EnemyRenderer loads shared AnimatedModel instances and renders enemy's CurrentModel (or fallback cubes).
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire model assignment in EnemyManager and BerzerkGame</name>
  <files>Berzerk/Source/Enemies/EnemyManager.cs, Berzerk/BerzerkGame.cs</files>
  <action>
Complete the wiring between enemy system and animated models:

**In EnemyManager.cs:**

Add reference to EnemyRenderer:
```csharp
private EnemyRenderer? _enemyRenderer;

/// <summary>
/// Set the renderer for model assignment.
/// </summary>
public void SetEnemyRenderer(EnemyRenderer renderer)
{
    _enemyRenderer = renderer;
}
```

Modify the enemy activation code (in SpawnEnemy or wherever enemies are activated from pool) to assign all three model references:
```csharp
// After activating enemy from pool, assign shared animated models
if (_enemyRenderer != null)
{
    var (idle, walk, attack) = _enemyRenderer.GetSharedModels();
    enemy.SetAnimatedModels(idle, walk, attack);
}
```

**In BerzerkGame.cs:**

In LoadContent, after creating EnemyRenderer, add model loading and wiring:
```csharp
// Initialize enemy renderer
_enemyRenderer = new EnemyRenderer(GraphicsDevice);
_enemyRenderer.LoadRobotModels(Content);  // Load shared robot models
_enemyManager.SetEnemyRenderer(_enemyRenderer);  // Wire to manager for spawn-time assignment
```

This completes the wiring:
- BerzerkGame loads shared robot models into EnemyRenderer
- EnemyManager gets reference to EnemyRenderer
- When enemies spawn, they get references to all three shared AnimatedModels
- EnemyController switches between models on state change
- EnemyRenderer draws enemy's CurrentModel (or fallback cubes)
  </action>
  <verify>
grep -q "LoadRobotModels" Berzerk/BerzerkGame.cs
grep -q "SetEnemyRenderer" Berzerk/Source/Enemies/EnemyManager.cs
grep -q "GetSharedModels" Berzerk/Source/Enemies/EnemyManager.cs
  </verify>
  <done>
Enemy animation system fully wired: shared models load, enemies get all model references at spawn, switch between models on state change.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. `dotnet build Berzerk/Berzerk.csproj` - Must compile without errors
2. `dotnet run --project Berzerk/Berzerk.csproj` - Game runs
3. If robot models were added:
   - Enemies render as animated robot models (not cubes)
   - Idle animation shows when enemy is in detection range waiting
   - Walk animation plays when enemies chase player
   - Attack animation plays when enemies are in attack state
4. If models skipped:
   - Enemies render as red cubes (placeholder)
   - Console shows "Robot models not found, using placeholder cubes"
   - Animation wiring exists, ready for models to be added later
5. Check ROADMAP.md has "direct movement chosen per Claude's discretion" text
6. Check REQUIREMENTS.md has updated AI-03 and AI-06

Key verification: Even without robot models, the animation system is wired and ready. Model switching follows the player's proven pattern.
</verification>

<success_criteria>
- EnemyController has model switching (SetCurrentModel switches between shared AnimatedModel instances)
- EnemyController stores references to all three models (idle, walk, attack)
- EnemyRenderer loads shared AnimatedModel instances and exposes them via GetSharedModels()
- EnemyRenderer renders enemy.CurrentModel (not a separate model reference)
- EnemyManager assigns all three model references to enemies on spawn
- BerzerkGame loads robot models and wires EnemyManager to EnemyRenderer
- ROADMAP updated to reflect direct movement was Claude's discretion
- REQUIREMENTS updated to reflect scope (no pathfinding requirement, score deferred)
- Game compiles and runs without crashes
</success_criteria>

<output>
After completion, create `.planning/phases/05-enemy-ai-combat/05-05-SUMMARY.md`
</output>
