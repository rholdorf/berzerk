---
phase: 05-enemy-ai-combat
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Berzerk/Source/Enemies/EnemyState.cs
  - Berzerk/Source/Enemies/EnemyHealth.cs
  - Berzerk/Source/Enemies/EnemyController.cs
  - Berzerk/Source/Combat/HealthPickup.cs
autonomous: true

must_haves:
  truths:
    - "Enemy can transition between Idle, Chase, Attack, and Dying states"
    - "Enemy health decreases when taking damage and fires death event at zero"
    - "Enemy moves toward player position when in Chase state"
    - "Health pickup can be collected to restore player health"
  artifacts:
    - path: "Berzerk/Source/Enemies/EnemyState.cs"
      provides: "FSM state enum for enemy AI"
      contains: "enum EnemyState"
    - path: "Berzerk/Source/Enemies/EnemyHealth.cs"
      provides: "Enemy health system with events"
      contains: "OnDeath"
    - path: "Berzerk/Source/Enemies/EnemyController.cs"
      provides: "Individual enemy behavior and movement"
      contains: "UpdateChaseState"
    - path: "Berzerk/Source/Combat/HealthPickup.cs"
      provides: "Collectable health restoration item"
      contains: "Heal"
  key_links:
    - from: "EnemyController"
      to: "EnemyHealth"
      via: "composition"
      pattern: "EnemyHealth.*Health"
    - from: "EnemyController"
      to: "EnemyState"
      via: "state machine"
      pattern: "_currentState"
---

<objective>
Create the core enemy infrastructure: state machine, health system, movement controller, and health pickup.

Purpose: Establish the foundational components for robot enemies before wiring them into the game. These mirror existing patterns (HealthSystem, PlayerController, AmmoPickup) for consistency.

Output: Four new classes - EnemyState enum, EnemyHealth, EnemyController, and HealthPickup - ready for manager integration in Plan 02.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-enemy-ai-combat/05-CONTEXT.md
@.planning/phases/05-enemy-ai-combat/05-RESEARCH.md

# Existing patterns to follow
@Berzerk/Source/Player/HealthSystem.cs
@Berzerk/Source/Controllers/PlayerController.cs
@Berzerk/Source/Combat/AmmoPickup.cs
@Berzerk/Source/Core/Transform.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create enemy state machine and health system</name>
  <files>
    Berzerk/Source/Enemies/EnemyState.cs
    Berzerk/Source/Enemies/EnemyHealth.cs
  </files>
  <action>
Create `Berzerk/Source/Enemies/` directory if needed.

**EnemyState.cs:**
Create enum with four states:
- `Idle` - Waiting, player not detected
- `Chase` - Moving toward player
- `Attack` - In melee range, dealing damage
- `Dying` - Playing death animation, about to despawn

**EnemyHealth.cs:**
Mirror existing HealthSystem pattern with:
- `MaxHealth = 30` (2-3 hits at 15 damage per laser, per CONTEXT)
- `CurrentHealth` property
- `IsDead` computed property
- `OnDamageTaken` event (Action)
- `OnDeath` event (Action)
- `TakeDamage(int amount)` method
- `Reset()` method for pooling

Use `namespace Berzerk.Source.Enemies;`
  </action>
  <verify>
Files compile with `dotnet build Berzerk/Berzerk.csproj`
  </verify>
  <done>
EnemyState enum has 4 states. EnemyHealth fires OnDamageTaken and OnDeath events correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create enemy controller with FSM movement</name>
  <files>Berzerk/Source/Enemies/EnemyController.cs</files>
  <action>
Create EnemyController following PlayerController and RESEARCH patterns:

**Properties:**
- `Transform` (use existing Transform class)
- `EnemyHealth Health` (composition)
- `bool IsActive` for pooling
- `BoundingSphere GetBoundingSphere()` for collision (radius 0.6f)

**Constants (per CONTEXT decisions):**
- `MoveSpeed = 3.5f` (70% of player's 5.0)
- `DetectionRange = 15f` (room is ~20 units, detect from far)
- `AttackRange = 2.5f` (melee distance)
- `AttackRangeExit = 3.5f` (hysteresis to prevent state thrashing)
- `AttackCooldown = 1.0f` seconds
- `AttackDamage = 10` HP (per CONTEXT)
- `GiveUpRange = 25f` (stop chasing if player escapes)

**FSM Implementation:**
- Private `_currentState = EnemyState.Idle`
- `Update(GameTime, Vector3 playerPos)` with switch statement
- `TransitionToState(EnemyState)` with OnStateEnter/OnStateExit hooks
- State update methods: UpdateIdleState, UpdateChaseState, UpdateAttackState, UpdateDyingState

**State behaviors:**
- Idle: Check if player within DetectionRange -> transition to Chase
- Chase: Move toward player (Vector3.Normalize), check AttackRange -> Attack, check GiveUpRange -> Idle
- Attack: Deal damage when cooldown ready, check AttackRangeExit -> Chase
- Dying: Wait for death animation timer (0.5s placeholder), set IsActive = false

**Movement:**
- `_velocity` vector for smooth movement
- Simple direct movement toward player (no complex pathfinding per RESEARCH)
- Keep movement horizontal (Y = 0)
- Use deltaTime for frame-rate independence

**Pooling support:**
- `Activate(Vector3 position)` - reset health, state, position, IsActive = true
- `Deactivate()` - IsActive = false, can be returned to pool

Subscribe Health.OnDeath to trigger transition to Dying state.
  </action>
  <verify>
File compiles. Verify FSM transitions compile correctly.
  </verify>
  <done>
EnemyController has working FSM with Idle/Chase/Attack/Dying states. Movement toward player implemented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create health pickup (mirrors AmmoPickup)</name>
  <files>Berzerk/Source/Combat/HealthPickup.cs</files>
  <action>
Create HealthPickup mirroring AmmoPickup pattern:

**Properties:**
- `Vector3 Position`
- `bool IsActive`
- `int HealAmount = 25` (reasonable heal for 10 HP attacks)
- `float CollectRadius = 2f` (same as AmmoPickup)

**Animation:**
- Same bobbing animation as AmmoPickup (sin wave, BOB_SPEED = 3f, BOB_HEIGHT = 0.3f)
- `GetDisplayPosition()` returns position with bob offset

**Methods:**
- `Activate(Vector3 position)` for pooling
- `Update(float deltaTime)` for bobbing
- `CheckCollection(Vector3 playerPosition)` returns bool
- `Collect()` deactivates and returns HealAmount
- `GetColor()` returns `Color.Green` (universal health indicator, per RESEARCH)

Use `namespace Berzerk.Source.Combat;` (same as AmmoPickup for consistency)
  </action>
  <verify>
File compiles. Pattern matches AmmoPickup structure.
  </verify>
  <done>
HealthPickup created with green color, bobbing animation, and collection mechanics.
  </done>
</task>

</tasks>

<verification>
1. All four files exist in correct directories
2. `dotnet build Berzerk/Berzerk.csproj` succeeds with no errors
3. EnemyState has 4 enum values
4. EnemyHealth has OnDeath event
5. EnemyController has Update method accepting playerPos
6. HealthPickup has GetColor returning Green
</verification>

<success_criteria>
- Enemy core infrastructure compiles and follows established patterns
- FSM has all four states with transition logic
- Health system fires events on damage and death
- Health pickup ready for drop integration
- No coupling to BerzerkGame yet (that's Plan 04)
</success_criteria>

<output>
After completion, create `.planning/phases/05-enemy-ai-combat/05-01-SUMMARY.md`
</output>
