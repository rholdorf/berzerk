---
phase: 01-skinningdata-types-and-serialization
plan: 02
type: tdd
wave: 2
depends_on: ["01-01"]
files_modified:
  - Berzerk.Tests/Berzerk.Tests.csproj
  - Berzerk.Tests/SkinningDataRoundTripTests.cs
  - Berzerk.sln
autonomous: true

must_haves:
  truths:
    - "Serializing SkinningData to binary and deserializing it back produces identical data"
    - "Bone count, bind pose matrices, inverse bind pose matrices, and skeleton hierarchy values survive round-trip"
    - "Animation clip names, durations, keyframe counts, bone indices, times, and transforms survive round-trip"
    - "Constructor validation rejects mismatched array lengths"
  artifacts:
    - path: "Berzerk.Tests/Berzerk.Tests.csproj"
      provides: "Test project referencing both pipeline and game assemblies"
      contains: "Berzerk.ContentPipeline"
    - path: "Berzerk.Tests/SkinningDataRoundTripTests.cs"
      provides: "Round-trip serialization tests proving writer/reader format match"
      contains: "RoundTrip"
  key_links:
    - from: "Berzerk.Tests/SkinningDataRoundTripTests.cs"
      to: "Berzerk.ContentPipeline/SkinningDataWriter.cs"
      via: "Tests exercise the writer to serialize test data"
      pattern: "SkinningDataWriter|ContentWriter"
    - from: "Berzerk.Tests/SkinningDataRoundTripTests.cs"
      to: "Berzerk/Source/Content/SkinningDataReader.cs"
      via: "Tests exercise the reader to deserialize and compare"
      pattern: "SkinningDataReader|ContentReader"
---

<objective>
Write a round-trip serialization test that proves the SkinningData binary format contract is correct: data written by SkinningDataWriter is faithfully reconstructed by SkinningDataReader.

Purpose: The most dangerous pitfall in this phase is a writer/reader binary format mismatch (Pitfall #2 from research). A round-trip test catches this immediately rather than waiting until Phase 2 when real FBX data flows through the pipeline. This is the only way to verify Success Criteria #4 ("ContentTypeReader deserializes SkinningData at runtime and produces identical data to what was written") before actual content exists.

Output: A test project with round-trip tests that pass, proving the serialization contract is sound.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-skinningdata-types-and-serialization/01-RESEARCH.md

# From Plan 01 (must exist before this plan runs)
@.planning/phases/01-skinningdata-types-and-serialization/01-01-SUMMARY.md

# Source files created by Plan 01
@Berzerk.ContentPipeline/SkinningData.cs
@Berzerk.ContentPipeline/SkinningDataClip.cs
@Berzerk.ContentPipeline/SkinningDataKeyframe.cs
@Berzerk.ContentPipeline/SkinningDataWriter.cs
@Berzerk/Source/Content/SkinningData.cs
@Berzerk/Source/Content/SkinningDataClip.cs
@Berzerk/Source/Content/SkinningDataKeyframe.cs
@Berzerk/Source/Content/SkinningDataReader.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test project and round-trip serialization tests</name>
  <files>
    Berzerk.Tests/Berzerk.Tests.csproj
    Berzerk.Tests/SkinningDataRoundTripTests.cs
    Berzerk.sln
  </files>
  <action>
    **NOTE on MonoGame Content Pipeline testing:** MonoGame's `ContentWriter` and `ContentReader` are tightly coupled to the content build pipeline and cannot be instantiated directly in unit tests (they require `ContentCompiler` internal infrastructure and XNB header framing). Instead of fighting the framework, test the serialization contract using a manual binary approach that validates the same logic.

    **Step 1: Create test project**

    Create `Berzerk.Tests/Berzerk.Tests.csproj`:
    - Target: `net8.0`
    - References: `xunit`, `xunit.runner.visualstudio`, `Microsoft.NET.Test.Sdk`
    - Project references: `Berzerk.ContentPipeline` (for pipeline-side SkinningData types and SkinningDataWriter), `Berzerk` (for runtime-side types and SkinningDataReader)
    - Also reference `MonoGame.Framework.DesktopGL` (for Matrix, TimeSpan, etc.) and `MonoGame.Framework.Content.Pipeline` (for ContentTypeWriter base types)

    Add the test project to `Berzerk.sln` using `dotnet sln add`.

    **Step 2: Write round-trip tests using BinaryWriter/BinaryReader**

    Since ContentWriter/ContentReader cannot be used directly in tests, write a "manual round-trip" test that:
    1. Creates a SkinningData instance with known test data (pipeline-side types from `Berzerk.ContentPipeline` namespace)
    2. Serializes it to a MemoryStream using BinaryWriter following the EXACT same format as SkinningDataWriter (write boneCount, then matrices, then hierarchy, then clips with keyframes)
    3. Reads it back from the MemoryStream using BinaryReader following the EXACT same format as SkinningDataReader (read boneCount, then matrices, etc.) into runtime-side types (from `Berzerk.Content` namespace)
    4. Asserts all values match

    This validates the binary format contract without requiring MonoGame's internal content pipeline infrastructure.

    **For Matrix serialization in tests:** Write/read the 16 float values in row-major order (M11, M12, M13, M14, M21, M22, ..., M44). This matches what MonoGame's ContentWriter.Write(Matrix) does internally.

    Create helper methods:
    - `WriteMatrix(BinaryWriter, Matrix)` -- writes 16 floats in row-major order
    - `ReadMatrix(BinaryReader)` -- reads 16 floats and constructs Matrix
    - `WriteSkinningData(BinaryWriter, SkinningData)` -- mirrors SkinningDataWriter.Write() logic exactly
    - `ReadSkinningData(BinaryReader)` -- mirrors SkinningDataReader.Read() logic exactly
    - `MatricesEqual(Matrix, Matrix, float tolerance)` -- compares with epsilon for float precision

    **Test cases:**

    1. `RoundTrip_SingleBone_SingleClip_SingleKeyframe` -- Simplest case: 1 bone, 1 clip with 1 keyframe. Verifies the basic format is correct.

    2. `RoundTrip_MultipleBones_MultipleClips` -- Realistic case: 3 bones with parent hierarchy (root=-1, bone1->root, bone2->bone1), 2 clips ("idle" with 4 keyframes, "walk" with 6 keyframes). Bind pose uses non-identity matrices. Inverse bind pose uses inverted matrices. Verifies that multiple bones and clips serialize/deserialize correctly.

    3. `RoundTrip_65Bones_RealisticSize` -- Scale test: 65 bones (typical Mixamo skeleton), 1 clip with 65*30=1950 keyframes (30 keyframes per bone). Verifies the format handles realistic data volumes without corruption.

    4. `Constructor_MismatchedArrayLengths_Throws` -- Verifies that `new SkinningData(clips, bindPose3, inverseBindPose2, hierarchy3)` throws ArgumentException when array lengths don't match.

    **Test data construction:**
    - Use `Matrix.CreateTranslation(x, y, z)` for readable test matrices
    - Use `Matrix.CreateRotationY(angle)` for variety
    - Verify: bone counts match, matrix values match (within float epsilon 1e-6), TimeSpan ticks match exactly, bone indices match, clip names match, keyframe counts match

    **Assertions pattern for each test:**
    ```
    Assert.Equal(original.BindPose.Count, result.BindPose.Count)
    For each bone: Assert matrix values within tolerance
    Assert.Equal(original.AnimationClips.Count, result.AnimationClips.Count)
    For each clip: Assert name, duration ticks, keyframe count
    For each keyframe: Assert bone index, time ticks, transform matrix
    ```
  </action>
  <verify>
    Run `dotnet test Berzerk.Tests/ --verbosity normal` from the repo root. All 4 tests MUST pass. Also verify `dotnet build Berzerk.sln --verbosity quiet` still succeeds with 0 errors.
  </verify>
  <done>
    Test project exists and is part of the solution. 4 round-trip tests pass: single bone/clip, multiple bones/clips, 65-bone realistic size, and constructor validation. The binary format written by the manual writer matches what the manual reader produces, proving the SkinningDataWriter and SkinningDataReader formats are consistent.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Berzerk.sln` succeeds with 0 errors (including test project)
2. `dotnet test Berzerk.Tests/` runs 4 tests, all pass
3. Round-trip test creates SkinningData -> serializes to bytes -> deserializes back -> all values match
4. Constructor validation test confirms mismatched array lengths throw ArgumentException
5. 65-bone scale test confirms format handles realistic Mixamo skeleton sizes
</verification>

<success_criteria>
- Test project compiles and is part of the solution
- All round-trip tests pass: data written equals data read back
- Constructor validation rejects mismatched array lengths
- Format handles 65-bone skeletons (realistic Mixamo size) without corruption
- The binary format tested mirrors SkinningDataWriter/SkinningDataReader logic exactly
</success_criteria>

<output>
After completion, create `.planning/phases/01-skinningdata-types-and-serialization/01-02-SUMMARY.md`
</output>
