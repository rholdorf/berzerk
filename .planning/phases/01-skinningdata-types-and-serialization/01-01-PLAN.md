---
phase: 01-skinningdata-types-and-serialization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Berzerk.ContentPipeline/SkinningData.cs
  - Berzerk.ContentPipeline/SkinningDataClip.cs
  - Berzerk.ContentPipeline/SkinningDataKeyframe.cs
  - Berzerk.ContentPipeline/SkinningDataWriter.cs
  - Berzerk/Source/Content/SkinningData.cs
  - Berzerk/Source/Content/SkinningDataClip.cs
  - Berzerk/Source/Content/SkinningDataKeyframe.cs
  - Berzerk/Source/Content/SkinningDataReader.cs
autonomous: true

must_haves:
  truths:
    - "SkinningData class exists with bind pose, inverse bind pose, skeleton hierarchy, and animation clips fields"
    - "AnimationClip data structure exists with duration and flat keyframe list (sorted by time)"
    - "Keyframe data structure exists with bone index, time, and transform matrix"
    - "ContentTypeWriter serializes SkinningData to binary format at build time"
    - "ContentTypeReader deserializes SkinningData from binary format at runtime"
    - "Old AnimationData types are untouched -- solution still compiles with both old and new types"
  artifacts:
    - path: "Berzerk.ContentPipeline/SkinningData.cs"
      provides: "Pipeline-side SkinningData container with AnimationClips dict, BindPose list, InverseBindPose list, SkeletonHierarchy list"
      contains: "class SkinningData"
    - path: "Berzerk.ContentPipeline/SkinningDataClip.cs"
      provides: "Pipeline-side AnimationClip with Duration and flat List<Keyframe>"
      contains: "class SkinningDataClip"
    - path: "Berzerk.ContentPipeline/SkinningDataKeyframe.cs"
      provides: "Pipeline-side Keyframe with Bone (int), Time (TimeSpan), Transform (Matrix)"
      contains: "class SkinningDataKeyframe"
    - path: "Berzerk.ContentPipeline/SkinningDataWriter.cs"
      provides: "ContentTypeWriter that serializes SkinningData to XNB binary"
      contains: "class SkinningDataWriter"
    - path: "Berzerk/Source/Content/SkinningData.cs"
      provides: "Runtime SkinningData deserialized from XNB"
      contains: "class SkinningData"
    - path: "Berzerk/Source/Content/SkinningDataClip.cs"
      provides: "Runtime AnimationClip with Duration and flat List<Keyframe>"
      contains: "class SkinningDataClip"
    - path: "Berzerk/Source/Content/SkinningDataKeyframe.cs"
      provides: "Runtime Keyframe with Bone, Time, Transform"
      contains: "class SkinningDataKeyframe"
    - path: "Berzerk/Source/Content/SkinningDataReader.cs"
      provides: "ContentTypeReader that deserializes SkinningData from XNB binary"
      contains: "class SkinningDataReader"
  key_links:
    - from: "Berzerk.ContentPipeline/SkinningDataWriter.cs"
      to: "Berzerk/Source/Content/SkinningDataReader.cs"
      via: "Binary format contract -- write order must exactly match read order"
      pattern: "boneCount.*BindPose.*InverseBindPose.*SkeletonHierarchy.*clipCount"
    - from: "Berzerk.ContentPipeline/SkinningDataWriter.cs"
      to: "Berzerk/Source/Content/SkinningDataReader.cs"
      via: "GetRuntimeReader returns exact fully-qualified reader type name"
      pattern: "Berzerk\\.Content\\.SkinningDataReader, Berzerk"
    - from: "Berzerk.ContentPipeline/SkinningDataWriter.cs"
      to: "Berzerk/Source/Content/SkinningData.cs"
      via: "GetRuntimeType returns exact fully-qualified runtime type name"
      pattern: "Berzerk\\.Content\\.SkinningData, Berzerk"
---

<objective>
Create the SkinningData type system (SkinningData, AnimationClip, Keyframe) in both pipeline and runtime assemblies, plus the ContentTypeWriter and ContentTypeReader for binary serialization.

Purpose: Establish the data contract between build-time FBX processing and runtime animation playback. These types are the foundation that every subsequent phase depends on. The existing AnimationData types are structurally insufficient (missing bind pose, inverse bind pose, skeleton hierarchy) -- the new SkinningData types follow the canonical XNA SkinnedModel pattern.

Output: 8 new source files (4 in pipeline assembly, 4 in runtime assembly). Solution compiles with both old and new types coexisting.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-skinningdata-types-and-serialization/01-RESEARCH.md

# Existing code for reference (do NOT modify these)
@Berzerk.ContentPipeline/AnimationData.cs
@Berzerk.ContentPipeline/AnimationClip.cs
@Berzerk.ContentPipeline/Keyframe.cs
@Berzerk.ContentPipeline/AnimationDataWriter.cs
@Berzerk/Source/Content/AnimationData.cs
@Berzerk/Source/Content/AnimationClip.cs
@Berzerk/Source/Content/Keyframe.cs
@Berzerk/Source/Content/AnimationDataReader.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SkinningData types in both assemblies</name>
  <files>
    Berzerk.ContentPipeline/SkinningData.cs
    Berzerk.ContentPipeline/SkinningDataClip.cs
    Berzerk.ContentPipeline/SkinningDataKeyframe.cs
    Berzerk/Source/Content/SkinningData.cs
    Berzerk/Source/Content/SkinningDataClip.cs
    Berzerk/Source/Content/SkinningDataKeyframe.cs
  </files>
  <action>
    Create 6 new files -- 3 in the pipeline assembly (`Berzerk.ContentPipeline/`) and 3 mirrored in the runtime assembly (`Berzerk/Source/Content/`). Do NOT modify or delete any existing files.

    IMPORTANT: Because `AnimationClip` and `Keyframe` classes already exist in both namespaces, name the new files and classes `SkinningDataClip` and `SkinningDataKeyframe` to avoid naming conflicts. The old types will be removed in Phase 2.

    **SkinningData class** (both assemblies, identical structure):
    - Namespace: `Berzerk.ContentPipeline` (pipeline) / `Berzerk.Content` (runtime)
    - Fields (all `{ get; private set; }`):
      - `Dictionary<string, SkinningDataClip> AnimationClips` -- clips keyed by name
      - `List<Matrix> BindPose` -- local-space bone rest transforms, one per bone
      - `List<Matrix> InverseBindPose` -- vertex-to-bonespace transforms, one per bone
      - `List<int> SkeletonHierarchy` -- parent index per bone, root bone has -1
    - Single constructor taking all 4 fields
    - Constructor MUST assert: `bindPose.Count == inverseBindPose.Count == skeletonHierarchy.Count` (throw ArgumentException if mismatch). This prevents the binary format mismatch pitfall where arrays have different lengths.
    - No parameterless constructor (immutable pattern)

    **SkinningDataClip class** (both assemblies, identical structure):
    - Fields:
      - `TimeSpan Duration { get; private set; }` -- total clip duration
      - `List<SkinningDataKeyframe> Keyframes { get; private set; }` -- flat sorted list of ALL keyframes for ALL bones
    - Single constructor: `SkinningDataClip(TimeSpan duration, List<SkinningDataKeyframe> keyframes)`
    - No parameterless constructor

    **SkinningDataKeyframe class** (both assemblies, identical structure):
    - Fields:
      - `int Bone { get; private set; }` -- bone index (matches BindPose/InverseBindPose/SkeletonHierarchy index)
      - `TimeSpan Time { get; private set; }` -- time offset from clip start
      - `Matrix Transform { get; private set; }` -- local-space bone transform at this time
    - Single constructor: `SkinningDataKeyframe(int bone, TimeSpan time, Matrix transform)`
    - No parameterless constructor

    Follow the XML doc comment style from the existing codebase (see existing AnimationData.cs, AnimationClip.cs, Keyframe.cs). Include meaningful summary comments on each class and each property describing what the field represents and how it relates to the animation pipeline.

    Use `using Microsoft.Xna.Framework;` for Matrix type. Use file-scoped namespace declarations (matching existing code style: `namespace Berzerk.ContentPipeline;`).
  </action>
  <verify>
    Run `dotnet build Berzerk.sln --verbosity quiet` from the repo root. Build MUST succeed with 0 errors. Existing code is untouched, new types compile alongside old types.
  </verify>
  <done>
    6 new .cs files exist. SkinningData has all 4 fields (AnimationClips, BindPose, InverseBindPose, SkeletonHierarchy). SkinningDataClip has Duration and flat Keyframes list. SkinningDataKeyframe has Bone, Time, Transform. All types are immutable (private setters, constructor-only initialization). Solution builds with 0 errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ContentTypeWriter and ContentTypeReader for SkinningData</name>
  <files>
    Berzerk.ContentPipeline/SkinningDataWriter.cs
    Berzerk/Source/Content/SkinningDataReader.cs
  </files>
  <action>
    Create the serialization pair that defines the binary contract between build-time and runtime.

    **SkinningDataWriter** (`Berzerk.ContentPipeline/SkinningDataWriter.cs`):
    - Namespace: `Berzerk.ContentPipeline`
    - Extends `ContentTypeWriter<SkinningData>`
    - Annotated with `[ContentTypeWriter]` attribute
    - `Write(ContentWriter output, SkinningData value)` method serializes in this EXACT order:
      ```
      1. boneCount (Int32) -- value.BindPose.Count
      2. For i in 0..boneCount-1: value.BindPose[i] (Matrix via output.Write(Matrix))
      3. For i in 0..boneCount-1: value.InverseBindPose[i] (Matrix)
      4. For i in 0..boneCount-1: value.SkeletonHierarchy[i] (Int32)
      5. clipCount (Int32) -- value.AnimationClips.Count
      6. For each clip in AnimationClips:
         a. clipName (String) -- dictionary key
         b. duration ticks (Int64) -- clip.Duration.Ticks
         c. keyframeCount (Int32) -- clip.Keyframes.Count
         d. For each keyframe:
            i.   bone (Int32) -- keyframe.Bone
            ii.  time ticks (Int64) -- keyframe.Time.Ticks
            iii. transform (Matrix) -- keyframe.Transform
      ```
    - Add inline comments documenting the binary format alongside each write call (so the reader author can match exactly)
    - `GetRuntimeReader()` returns EXACTLY: `"Berzerk.Content.SkinningDataReader, Berzerk"`
    - `GetRuntimeType()` returns EXACTLY: `"Berzerk.Content.SkinningData, Berzerk"`
    - CRITICAL: These strings must match the runtime namespace (`Berzerk.Content`), class names, and assembly name (`Berzerk`). If wrong, Model.Tag will silently be null at runtime.

    **SkinningDataReader** (`Berzerk/Source/Content/SkinningDataReader.cs`):
    - Namespace: `Berzerk.Content`
    - Extends `ContentTypeReader<SkinningData>`
    - `Read(ContentReader input, SkinningData existingInstance)` method reads in EXACTLY the same order as the writer writes:
      ```
      1. boneCount = ReadInt32()
      2. bindPose = new List<Matrix>(boneCount), loop ReadMatrix()
      3. inverseBindPose = new List<Matrix>(boneCount), loop ReadMatrix()
      4. skeletonHierarchy = new List<int>(boneCount), loop ReadInt32()
      5. clipCount = ReadInt32()
      6. For each clip:
         a. clipName = ReadString()
         b. duration = TimeSpan.FromTicks(ReadInt64())
         c. keyframeCount = ReadInt32()
         d. keyframes = new List<SkinningDataKeyframe>(keyframeCount)
         e. For each keyframe: bone=ReadInt32(), time=FromTicks(ReadInt64()), transform=ReadMatrix()
         f. animationClips[clipName] = new SkinningDataClip(duration, keyframes)
      7. Return new SkinningData(animationClips, bindPose, inverseBindPose, skeletonHierarchy)
      ```
    - Pre-allocate lists with capacity (pass count to List constructor) for efficiency
    - Add inline comments that mirror the writer's format comments

    Use the existing `AnimationDataWriter.cs` and `AnimationDataReader.cs` as style reference for using directives, class structure, and XML doc comments. Use `using Microsoft.Xna.Framework.Content.Pipeline;` and `using Microsoft.Xna.Framework.Content.Pipeline.Serialization.Compiler;` in the writer. Use `using Microsoft.Xna.Framework.Content;` in the reader.
  </action>
  <verify>
    Run `dotnet build Berzerk.sln --verbosity quiet` from the repo root. Build MUST succeed with 0 errors. Verify that `GetRuntimeReader` returns `"Berzerk.Content.SkinningDataReader, Berzerk"` and `GetRuntimeType` returns `"Berzerk.Content.SkinningData, Berzerk"` by searching the file content.
  </verify>
  <done>
    SkinningDataWriter.cs exists in pipeline assembly and serializes SkinningData to binary. SkinningDataReader.cs exists in runtime assembly and deserializes from binary. The write order and read order are identical. GetRuntimeReader and GetRuntimeType return correctly-qualified type strings. Solution builds with 0 errors.
  </done>
</task>

</tasks>

<verification>
1. `dotnet build Berzerk.sln` succeeds with 0 errors
2. All 8 new files exist at their expected paths
3. No existing files were modified (old AnimationData/AnimationClip/Keyframe untouched)
4. SkinningData constructor validates that BindPose, InverseBindPose, and SkeletonHierarchy have equal counts
5. Writer binary format order matches reader binary format order (verified by code review)
6. GetRuntimeReader returns "Berzerk.Content.SkinningDataReader, Berzerk"
7. GetRuntimeType returns "Berzerk.Content.SkinningData, Berzerk"
</verification>

<success_criteria>
- SkinningData type exists with all 4 fields (AnimationClips, BindPose, InverseBindPose, SkeletonHierarchy)
- SkinningDataClip type exists with Duration and flat Keyframes list
- SkinningDataKeyframe type exists with Bone, Time, Transform
- ContentTypeWriter serializes SkinningData to binary
- ContentTypeReader deserializes SkinningData from binary
- All types are immutable (private setters)
- Solution compiles cleanly with old and new types coexisting
</success_criteria>

<output>
After completion, create `.planning/phases/01-skinningdata-types-and-serialization/01-01-SUMMARY.md`
</output>
