---
phase: 03-animation-runtime
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - Berzerk/Source/Graphics/AnimationPlayer.cs
  - Berzerk/Source/Graphics/AnimatedModel.cs
  - Berzerk/Source/Content/AnimationData.cs
  - Berzerk/Source/Content/AnimationClip.cs
  - Berzerk/Source/Content/Keyframe.cs
  - Berzerk/Source/Content/AnimationDataReader.cs
autonomous: true

must_haves:
  truths:
    - "AnimationPlayer implements three-stage pipeline: keyframe decode, hierarchy composition, inverse bind pose"
    - "Playing an animation clip produces changing skinTransforms each frame"
    - "Multiple clips from separate FBX files are available in the animation dictionary"
    - "Switching clips changes which animation plays, starting from the beginning"
    - "Looping animation restarts when it reaches the end"
    - "Old AnimationData/AnimationClip/Keyframe/AnimationDataReader types are deleted"
    - "Solution compiles and game runs (still T-pose, but no crash)"
  artifacts:
    - path: "Berzerk/Source/Graphics/AnimationPlayer.cs"
      provides: "Three-stage skinning transform pipeline"
      min_lines: 60
      exports: ["AnimationPlayer"]
    - path: "Berzerk/Source/Graphics/AnimatedModel.cs"
      provides: "Refactored model loading using SkinningData + AnimationPlayer"
      contains: "SkinningData"
  key_links:
    - from: "Berzerk/Source/Graphics/AnimatedModel.cs"
      to: "Berzerk/Source/Graphics/AnimationPlayer.cs"
      via: "AnimatedModel creates and calls AnimationPlayer"
      pattern: "_animationPlayer\\.(Update|StartClip)"
    - from: "Berzerk/Source/Graphics/AnimatedModel.cs"
      to: "Berzerk/Source/Content/SkinningData.cs"
      via: "Model.Tag cast to SkinningData"
      pattern: "Model\\.Tag as SkinningData"
    - from: "Berzerk/Source/Graphics/AnimationPlayer.cs"
      to: "Berzerk/Source/Content/SkinningData.cs"
      via: "AnimationPlayer reads BindPose, InverseBindPose, SkeletonHierarchy"
      pattern: "skinningData\\.(BindPose|InverseBindPose|SkeletonHierarchy)"
---

<objective>
Create AnimationPlayer with three-stage transform pipeline, refactor AnimatedModel to use SkinningData, and delete old runtime types.

Purpose: Replace the broken old animation system (string-based bone lookup, Matrix.Decompose interpolation, wrong bone ordering) with the canonical XNA AnimationPlayer pattern (integer bone indices, flat keyframe scan, hierarchy composition, inverse bind pose). This is the core runtime math that produces correct skinning matrices for Phase 4's GPU rendering.

Output: AnimationPlayer.cs (new), AnimatedModel.cs (rewritten), 4 old files deleted. Game compiles and runs (still T-pose until Phase 4 connects skinTransforms to SkinnedEffect).
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-animation-runtime/03-RESEARCH.md
@Berzerk/Source/Content/SkinningData.cs
@Berzerk/Source/Content/SkinningDataClip.cs
@Berzerk/Source/Content/SkinningDataKeyframe.cs
@Berzerk/Source/Graphics/AnimatedModel.cs
@Berzerk/Source/Enemies/EnemyRenderer.cs
@Berzerk/Source/Enemies/EnemyController.cs
@Berzerk/BerzerkGame.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AnimationPlayer with three-stage transform pipeline</name>
  <files>Berzerk/Source/Graphics/AnimationPlayer.cs</files>
  <action>
    Create `Berzerk/Source/Graphics/AnimationPlayer.cs` -- a direct port of the XNA SkinningSample_4_0 AnimationPlayer,
    adapted to use the existing Berzerk SkinningData/SkinningDataClip/SkinningDataKeyframe types.

    Namespace: `Berzerk.Graphics`

    The class must implement:

    **Constructor: AnimationPlayer(SkinningData skinningData)**
    - Store skinningData reference
    - Allocate three Matrix arrays sized to skinningData.BindPose.Count:
      - boneTransforms (Stage 1: local space from keyframes)
      - worldTransforms (Stage 2: model space from hierarchy)
      - skinTransforms (Stage 3: for GPU, after inverse bind pose)

    **StartClip(SkinningDataClip clip)**
    - Set currentClip, reset currentTime to TimeSpan.Zero, reset currentKeyframe to 0
    - CRITICAL: Copy BindPose into boneTransforms via `skinningData.BindPose.CopyTo(boneTransforms, 0)`
      (List<Matrix>.CopyTo(Matrix[], int) works correctly in .NET)

    **Update(TimeSpan time, bool relativeToCurrentTime, Matrix rootTransform)**
    - Convenience method that calls all three stages in order:
      UpdateBoneTransforms(time, relativeToCurrentTime)
      UpdateWorldTransforms(rootTransform)
      UpdateSkinTransforms()

    **UpdateBoneTransforms(TimeSpan time, bool relativeToCurrentTime)**
    - If relativeToCurrentTime, add time to currentTime
    - Loop handling: `while (time >= currentClip.Duration) time -= currentClip.Duration`
      (use the computed absolute time after adding, not the parameter -- match XNA exactly)
    - If time went backwards (time < currentTime), reset: currentKeyframe = 0,
      re-copy BindPose to boneTransforms
    - Set currentTime = time
    - Scan forward through currentClip.Keyframes flat list:
      while (currentKeyframe < keyframes.Count && keyframes[currentKeyframe].Time <= currentTime)
        boneTransforms[kf.Bone] = kf.Transform; currentKeyframe++;
    - NOTE: No interpolation. The flat keyframe scan overwrites boneTransforms directly.
      Mixamo 30fps data makes interpolation unnecessary.

    **UpdateWorldTransforms(Matrix rootTransform)**
    - worldTransforms[0] = boneTransforms[0] * rootTransform
    - For bone 1..N: worldTransforms[bone] = boneTransforms[bone] * worldTransforms[parentBone]
      where parentBone = skinningData.SkeletonHierarchy[bone]

    **UpdateSkinTransforms()**
    - For each bone: skinTransforms[bone] = skinningData.InverseBindPose[bone] * worldTransforms[bone]

    **GetSkinTransforms() => skinTransforms** (public property or method)

    **CurrentClip property** (read-only, returns currentClip -- used by AnimatedModel to check if playing)

    Do NOT add: interpolation, blending, speed control, events. Those are out of scope.

    Match the XNA SkinningSample_4_0 source code from the research exactly in logic. Adapt only type names
    (SkinningDataClip, SkinningDataKeyframe, SkinningData) and field access patterns (Bone, Time, Transform
    on SkinningDataKeyframe; BindPose, InverseBindPose, SkeletonHierarchy on SkinningData).
  </action>
  <verify>File exists with correct namespace, class compiles (check during Task 2 build).</verify>
  <done>AnimationPlayer.cs exists implementing three-stage pipeline with StartClip, Update, GetSkinTransforms.</done>
</task>

<task type="auto">
  <name>Task 2: Rewrite AnimatedModel, delete old types, verify build</name>
  <files>
    Berzerk/Source/Graphics/AnimatedModel.cs
    Berzerk/Source/Content/AnimationData.cs
    Berzerk/Source/Content/AnimationClip.cs
    Berzerk/Source/Content/Keyframe.cs
    Berzerk/Source/Content/AnimationDataReader.cs
  </files>
  <action>
    **Part A: Rewrite AnimatedModel.cs**

    Replace the internals of AnimatedModel to use SkinningData + AnimationPlayer instead of AnimationData.
    PRESERVE the public API surface so callers (BerzerkGame.cs, EnemyRenderer.cs, EnemyController.cs)
    do not need changes.

    Fields to replace:
    - DELETE: `AnimationData? _animationData`, `TimeSpan _currentTime`, `int _debugFrameCount`
    - ADD: `SkinningData? _skinningData`, `AnimationPlayer? _animationPlayer`
    - KEEP: `Model? _model`, `Matrix[] _boneTransforms`, `string? _currentClipName`

    **LoadContent(ContentManager content, string modelPath):**
    - Load model as before
    - Cast `_model.Tag as SkinningData` (not AnimationData)
    - If SkinningData found AND has bones (BindPose.Count > 0):
      - Create `_animationPlayer = new AnimationPlayer(_skinningData)`
      - Log bone count and clip names
    - If SkinningData found but has 0 bones (animation-only file):
      - Log that it's animation-only, no player needed
    - If no SkinningData: log static model
    - Keep initializing _boneTransforms from Model.Bones (needed for Draw which still uses BasicEffect)

    **Update(GameTime gameTime):**
    - If _animationPlayer is null or no current clip, return
    - Call `_animationPlayer.Update(gameTime.ElapsedGameTime, true, Matrix.Identity)`
    - That's it. The AnimationPlayer handles looping, keyframe scanning, hierarchy, everything.
    - NOTE: Do NOT update _boneTransforms from AnimationPlayer output yet. The Draw() method still
      uses BasicEffect with Model.Bones transforms (Phase 4 switches to SkinnedEffect + skinTransforms).

    **PlayAnimation(string clipName):**
    - If _skinningData is null, log warning, return
    - Look up clip: `_skinningData.AnimationClips.TryGetValue(clipName, out var clip)`
    - If found: `_animationPlayer.StartClip(clip)`, set _currentClipName
    - If not found: log warning

    **GetAnimationNames():**
    - Return `_skinningData.AnimationClips.Keys.ToList()` (or empty list if null)

    **AddAnimationsFrom(ContentManager content, string animationPath, string? animationName = null):**
    - Load animation model, cast Tag to SkinningData
    - If animation SkinningData is null, log and return
    - Merge clips: for each clip in animSkinningData.AnimationClips,
      add to _skinningData.AnimationClips with custom name (animationName ?? clipEntry.Key)
    - Skip if clip name already exists (log warning)
    - NOTE: If _skinningData is null (base model had no SkinningData), log error and return.
      Do NOT create a new SkinningData from nothing (unlike old code which created empty AnimationData).

    **Draw(...):**
    - KEEP EXACTLY AS-IS. Do not change Draw(). It uses BasicEffect with Model.Bones transforms.
      Phase 4 will change this to SkinnedEffect + skinTransforms.

    **DELETE:** `ApplyKeyframes()` method entirely. DELETE `InterpolateTransform()` method entirely.

    **Part B: Delete old runtime types**

    Delete these 4 files (they are superseded by SkinningData/SkinningDataClip/SkinningDataKeyframe/SkinningDataReader):
    - Berzerk/Source/Content/AnimationData.cs
    - Berzerk/Source/Content/AnimationClip.cs
    - Berzerk/Source/Content/Keyframe.cs
    - Berzerk/Source/Content/AnimationDataReader.cs

    **Part C: Build and verify**

    Run `dotnet build` from solution root. The build MUST succeed. All references to old types
    are in AnimatedModel.cs which was rewritten, so there should be no dangling references.

    If compile errors appear referencing AnimationData, AnimationClip, or Keyframe, fix them --
    they are likely `using Berzerk.Content;` statements that are fine to keep (SkinningData types
    use the same namespace).

    Verify the game launches without crash (it will still show T-pose, which is expected).
  </action>
  <verify>
    `dotnet build` succeeds with zero errors. Game launches without crash.
    Old files AnimationData.cs, AnimationClip.cs, Keyframe.cs, AnimationDataReader.cs no longer exist.
    AnimatedModel.cs contains `SkinningData` and `AnimationPlayer` references, no `AnimationData` references.
  </verify>
  <done>
    AnimatedModel uses SkinningData + AnimationPlayer. Old types deleted. Solution compiles.
    Game runs (T-pose expected -- skinTransforms computed but not yet sent to GPU, that is Phase 4).
  </done>
</task>

</tasks>

<verification>
1. `dotnet build` succeeds with zero errors
2. AnimationPlayer.cs exists with UpdateBoneTransforms, UpdateWorldTransforms, UpdateSkinTransforms, StartClip, GetSkinTransforms
3. AnimatedModel.cs casts Model.Tag to SkinningData (not AnimationData)
4. AnimatedModel.cs creates AnimationPlayer in LoadContent
5. AnimatedModel.cs calls _animationPlayer.Update() in Update()
6. AnimatedModel.cs calls _animationPlayer.StartClip() in PlayAnimation()
7. Old files deleted: AnimationData.cs, AnimationClip.cs, Keyframe.cs, AnimationDataReader.cs
8. No references to old types remain in any .cs file (grep for AnimationData should find 0 results outside deleted files)
9. Game launches and renders (T-pose expected, no crash)
</verification>

<success_criteria>
- AnimationPlayer implements exact XNA three-stage pipeline (ANIM-01, ANIM-02, ANIM-03, ANIM-04)
- Looping works via while-subtract pattern with backwards-time detection (ANIM-05)
- AddAnimationsFrom merges clips from separate models by name (ANIM-06)
- PlayAnimation switches clips via StartClip (ANIM-07)
- Old types deleted, solution compiles, game runs
</success_criteria>

<output>
After completion, create `.planning/phases/03-animation-runtime/03-02-SUMMARY.md`
</output>
