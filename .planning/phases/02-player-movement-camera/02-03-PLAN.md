---
phase: 02-player-movement-camera
plan: 03
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - Berzerk/Source/Graphics/ThirdPersonCamera.cs
autonomous: true

must_haves:
  truths:
    - "Camera follows player with smooth spring interpolation"
    - "Scroll wheel adjusts camera distance"
    - "Camera angle transitions from eye-level (close) to high angle (far)"
    - "Right-click drag orbits camera around player"
    - "Camera zooms in when hitting walls (collision detection)"
  artifacts:
    - path: "Berzerk/Source/Graphics/ThirdPersonCamera.cs"
      provides: "Third-person camera with follow, zoom, orbit, collision"
      min_lines: 120
      contains: "Ray"
  key_links:
    - from: "ThirdPersonCamera"
      to: "InputManager"
      via: "ScrollWheelDelta, MouseDelta, IsRightMouseHeld"
      pattern: "_inputManager\\.ScrollWheelDelta|MouseDelta|IsRightMouseHeld"
    - from: "ThirdPersonCamera"
      to: "Ray.Intersects"
      via: "collision detection raycast"
      pattern: "Ray.*Intersects"
---

<objective>
Implement ThirdPersonCamera with smooth following, scroll wheel zoom, right-click orbit, collision detection, and angle transitions.

Purpose: Complete camera system for third-person gameplay - MOVE-03, MOVE-04, MOVE-05
Output: ThirdPersonCamera.cs with all camera behaviors
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-player-movement-camera/02-CONTEXT.md
@.planning/phases/02-player-movement-camera/02-RESEARCH.md
@.planning/phases/02-player-movement-camera/02-01-SUMMARY.md

# Source files
@Berzerk/Source/Input/InputManager.cs
@Berzerk/Source/Core/Transform.cs
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ThirdPersonCamera with smooth following and zoom</name>
  <files>Berzerk/Source/Graphics/ThirdPersonCamera.cs</files>
  <action>
Create ThirdPersonCamera.cs in Berzerk/Source/Graphics/:

**From CONTEXT.md decisions:**
- Light spring smoothing (simple exponential decay Lerp, not full spring-damper)
- Scroll wheel: up = closer, down = farther
- Camera angle transitions: eye-level when close, high angle when far

**From RESEARCH.md:**
- Use exponential decay: `smoothFactor = 1f - MathF.Pow(dampingCoeff, deltaTime)`
- Frame-rate independent smoothing is critical

```csharp
namespace Berzerk.Graphics;

public class ThirdPersonCamera
{
    private InputManager _inputManager;
    private Transform _target;  // Player's transform to follow

    // Camera state
    private Vector3 _currentPosition;
    private float _currentDistance = 5f;
    private float _currentYaw = 0f;   // Horizontal angle (radians)
    private float _currentPitch = 0f; // Vertical angle (radians)

    // Distance settings
    private const float MinDistance = 2f;
    private const float MaxDistance = 15f;
    private const float ZoomSpeed = 0.01f;  // Units per scroll delta

    // Angle settings (for distance-based angle transition)
    private const float MinPitch = 0f;           // Eye-level when close (radians)
    private const float MaxPitch = MathF.PI / 6; // 30 degrees down when far

    // Orbit settings (right-click drag)
    private const float OrbitSensitivity = 0.005f;
    private const float PitchMin = -MathF.PI / 4;  // Max look up (-45 degrees)
    private const float PitchMax = MathF.PI / 3;   // Max look down (60 degrees)

    // Smoothing
    private const float PositionDamping = 0.01f;  // Lower = more responsive
    private const float DistanceDamping = 0.05f;

    // Collision
    private List<BoundingBox> _collisionGeometry = new();
    private const float CollisionOffset = 0.3f;  // Don't clip exactly at surface

    // Output matrices
    public Matrix ViewMatrix { get; private set; }
    public Matrix ProjectionMatrix { get; private set; }

    public ThirdPersonCamera(InputManager inputManager, Transform target)
    {
        _inputManager = inputManager;
        _target = target;
        _currentPosition = target.Position + GetDesiredOffset();
    }

    public void Initialize(GraphicsDevice graphicsDevice)
    {
        ProjectionMatrix = Matrix.CreatePerspectiveFieldOfView(
            MathHelper.PiOver4,
            graphicsDevice.Viewport.AspectRatio,
            0.1f,
            1000f
        );
    }

    public void SetCollisionGeometry(List<BoundingBox> geometry)
    {
        _collisionGeometry = geometry;
    }

    public void Update(GameTime gameTime)
    {
        float deltaTime = (float)gameTime.ElapsedGameTime.TotalSeconds;

        // 1. Handle zoom (scroll wheel)
        HandleZoom();

        // 2. Handle orbit (right-click drag)
        HandleOrbit(deltaTime);

        // 3. Calculate automatic pitch based on distance
        UpdateAutoPitch();

        // 4. Calculate desired camera position
        Vector3 desiredPosition = _target.Position + GetDesiredOffset();

        // 5. Apply collision detection
        float finalDistance = CheckCollision(_target.Position, desiredPosition);
        Vector3 collisionAdjustedPosition = _target.Position + GetOffsetAtDistance(finalDistance);

        // 6. Smooth camera position (exponential decay lerp)
        float smoothFactor = 1f - MathF.Pow(PositionDamping, deltaTime);
        _currentPosition = Vector3.Lerp(_currentPosition, collisionAdjustedPosition, smoothFactor);

        // 7. Update view matrix
        Vector3 lookAt = _target.Position + new Vector3(0, 1f, 0); // Look at player chest height
        ViewMatrix = Matrix.CreateLookAt(_currentPosition, lookAt, Vector3.Up);
    }

    private void HandleZoom()
    {
        int scrollDelta = _inputManager.ScrollWheelDelta;
        if (scrollDelta != 0)
        {
            // Scroll up = zoom in (decrease distance), scroll down = zoom out
            _currentDistance -= scrollDelta * ZoomSpeed;
            _currentDistance = MathHelper.Clamp(_currentDistance, MinDistance, MaxDistance);
        }
    }

    private void HandleOrbit(float deltaTime)
    {
        if (_inputManager.IsRightMouseHeld())
        {
            var mouseDelta = _inputManager.MouseDelta;

            // Horizontal: yaw (rotate around Y axis)
            _currentYaw -= mouseDelta.X * OrbitSensitivity;

            // Vertical: pitch (limited up/down)
            _currentPitch += mouseDelta.Y * OrbitSensitivity;
            _currentPitch = MathHelper.Clamp(_currentPitch, PitchMin, PitchMax);
        }
    }

    private void UpdateAutoPitch()
    {
        // When not manually orbiting, blend pitch based on distance
        // Close = more eye-level, Far = more top-down
        if (!_inputManager.IsRightMouseHeld())
        {
            float distanceNormalized = (_currentDistance - MinDistance) / (MaxDistance - MinDistance);
            float autoPitch = MathHelper.Lerp(MinPitch, MaxPitch, distanceNormalized);

            // Blend toward auto pitch slowly when not orbiting
            _currentPitch = MathHelper.Lerp(_currentPitch, autoPitch, 0.05f);
        }
    }

    private Vector3 GetDesiredOffset()
    {
        return GetOffsetAtDistance(_currentDistance);
    }

    private Vector3 GetOffsetAtDistance(float distance)
    {
        // Spherical coordinates to Cartesian
        // Yaw: rotation around Y axis, Pitch: angle from horizontal
        float horizontalDist = distance * MathF.Cos(_currentPitch);
        float verticalDist = distance * MathF.Sin(_currentPitch);

        Vector3 offset = new Vector3(
            horizontalDist * MathF.Sin(_currentYaw),
            verticalDist + 1f,  // +1 for player height offset
            horizontalDist * MathF.Cos(_currentYaw)
        );

        return offset;
    }

    private float CheckCollision(Vector3 playerPos, Vector3 desiredCameraPos)
    {
        if (_collisionGeometry.Count == 0)
            return _currentDistance;

        Vector3 direction = desiredCameraPos - playerPos;
        float desiredDistance = direction.Length();

        if (desiredDistance < 0.001f)
            return _currentDistance;

        direction = Vector3.Normalize(direction);
        Ray ray = new Ray(playerPos, direction);

        float closestHit = desiredDistance;

        foreach (var box in _collisionGeometry)
        {
            float? intersection = ray.Intersects(box);
            if (intersection.HasValue && intersection.Value < closestHit)
            {
                closestHit = intersection.Value;
            }
        }

        // Apply collision offset (don't clip exactly at surface)
        float finalDistance = MathF.Max(closestHit - CollisionOffset, MinDistance);

        // Smooth zoom back out when collision clears
        float distanceSmoothFactor = 1f - MathF.Pow(DistanceDamping, 0.016f); // Assume ~60fps for distance smooth
        return MathHelper.Lerp(_currentDistance, finalDistance, distanceSmoothFactor);
    }
}
```

Include usings: Microsoft.Xna.Framework, Microsoft.Xna.Framework.Graphics, Berzerk.Source.Input, Berzerk.Core, System, System.Collections.Generic
  </action>
  <verify>
Build succeeds: `dotnet build Berzerk/Berzerk.csproj`
ThirdPersonCamera.cs exists with Update, HandleZoom, HandleOrbit, CheckCollision methods
  </verify>
  <done>
ThirdPersonCamera handles smooth following, scroll wheel zoom with distance-based angle, right-click orbit, and collision detection with smooth zoom-in
  </done>
</task>

<task type="auto">
  <name>Task 2: Add test collision geometry setup method</name>
  <files>Berzerk/Source/Graphics/ThirdPersonCamera.cs</files>
  <action>
Add a static helper method to ThirdPersonCamera for creating test walls (to be used in integration plan):

```csharp
/// <summary>
/// Creates test collision geometry for camera collision testing.
/// Call this during initialization to set up placeholder walls.
/// </summary>
public static List<BoundingBox> CreateTestWalls()
{
    return new List<BoundingBox>
    {
        // Left wall
        new BoundingBox(new Vector3(-15, 0, -15), new Vector3(-14, 5, 15)),
        // Right wall
        new BoundingBox(new Vector3(14, 0, -15), new Vector3(15, 5, 15)),
        // Back wall
        new BoundingBox(new Vector3(-15, 0, -15), new Vector3(15, 5, -14)),
        // Front wall
        new BoundingBox(new Vector3(-15, 0, 14), new Vector3(15, 5, 15)),
        // Center pillar (for testing collision while moving)
        new BoundingBox(new Vector3(-1, 0, -8), new Vector3(1, 4, -6)),
    };
}
```

This provides a test arena with walls and a center pillar for testing camera collision behavior.
  </action>
  <verify>
Build succeeds: `dotnet build Berzerk/Berzerk.csproj`
CreateTestWalls method exists and returns List of BoundingBox
  </verify>
  <done>
ThirdPersonCamera includes test geometry helper for validating camera collision in integration plan
  </done>
</task>

</tasks>

<verification>
After all tasks:
1. `dotnet build Berzerk/Berzerk.csproj` succeeds
2. ThirdPersonCamera.cs compiles with all methods
3. Camera provides ViewMatrix and ProjectionMatrix
4. Scroll wheel zoom logic implemented
5. Right-click orbit logic implemented
6. Collision detection with Ray.Intersects implemented
7. Test walls helper ready for integration
</verification>

<success_criteria>
- ThirdPersonCamera ready for integration (not integrated yet - that's Plan 04)
- Smooth following using exponential decay lerp
- Zoom with distance-based angle transition
- Orbit with right-click drag
- Collision detection with smooth zoom-in behavior
- All frame-rate independent calculations
</success_criteria>

<output>
After completion, create `.planning/phases/02-player-movement-camera/02-03-SUMMARY.md`
</output>
