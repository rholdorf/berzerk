---
phase: 06-room-system-progression
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - Berzerk/BerzerkGame.cs
  - Berzerk/Source/Enemies/EnemyManager.cs
autonomous: true

must_haves:
  truths:
    - "Room collision geometry replaces test walls"
    - "Doors open when all enemies are defeated"
    - "Player walking into open door triggers room transition"
    - "Room transition spawns fresh enemies"
    - "Player spawns at correct door after transition"
    - "Projectiles cleared on room transition"
  artifacts:
    - path: "Berzerk/BerzerkGame.cs"
      provides: "Full room system integration"
      contains: ["RoomManager", "RoomRenderer", "OnRoomTransition"]
    - path: "Berzerk/Source/Enemies/EnemyManager.cs"
      provides: "OnAllEnemiesDefeated event"
      contains: "OnAllEnemiesDefeated"
  key_links:
    - from: "Berzerk/BerzerkGame.cs"
      to: "Berzerk/Source/Rooms/RoomManager.cs"
      via: "Event subscription"
      pattern: "_roomManager\\.OnRoomTransition"
    - from: "Berzerk/BerzerkGame.cs"
      to: "Berzerk/Source/Enemies/EnemyManager.cs"
      via: "Event subscription for room clear"
      pattern: "_enemyManager\\.OnAllEnemiesDefeated"
    - from: "Berzerk/Source/Enemies/EnemyManager.cs"
      to: "Berzerk/Source/Rooms/RoomManager.cs"
      via: "Event firing"
      pattern: "OnAllEnemiesDefeated\\?.Invoke"
---

<objective>
Integrate room system into BerzerkGame: wire RoomManager events, replace test walls with room geometry, handle room transitions with fresh enemy spawns.

Purpose: Complete the room progression loop - clear room, doors open, enter door, new room with enemies. This is the core Berzerk gameplay loop.
Output: Fully functional room system with door-based progression.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-room-system-progression/06-RESEARCH.md
@Berzerk/BerzerkGame.cs
@Berzerk/Source/Enemies/EnemyManager.cs

Key integration points:
1. Replace _testWalls with RoomManager.GetCollisionGeometry()
2. Add OnAllEnemiesDefeated event to EnemyManager (fires when _enemies.Count == 0)
3. Wire EnemyManager.OnAllEnemiesDefeated -> RoomManager.HandleAllEnemiesDefeated
4. Wire RoomManager.OnRoomTransition -> HandleRoomTransition (in BerzerkGame)
5. HandleRoomTransition: reset enemies, clear projectiles, move player, increment room counter

Existing patterns to follow:
- Event wiring in Initialize/LoadContent (like HealthSystem.OnDeath)
- Manager Update calls in UpdatePlaying (like _enemyManager.Update)
- Manager Draw calls in Draw (like _enemyRenderer.DrawEnemies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add OnAllEnemiesDefeated event to EnemyManager</name>
  <files>Berzerk/Source/Enemies/EnemyManager.cs</files>
  <action>
Add event that fires when all enemies are defeated. Modify EnemyManager.cs:

1. Add event declaration after AllEnemiesDefeated property:
```csharp
/// <summary>
/// Event fired when all enemies in room are defeated.
/// </summary>
public event Action OnAllEnemiesDefeated;
```

2. Modify the Update method's enemy return-to-pool loop to check and fire the event.
After the loop that returns inactive enemies to pool (around line 237), add:
```csharp
// Check if room is now clear (all enemies defeated)
if (_enemies.Count == 0 && ActiveCount == 0)
{
    // Only fire if we had enemies before (not on initial empty state)
    // This is handled by checking in the death handler instead
}
```

Actually, better approach: fire the event in the OnEnemyDeath handler after removing from list.
Modify OnEnemyDeath method - add at the end, after drop logic:
```csharp
// Check if this was the last enemy
// Note: Check after enemy is marked for removal but before next Update removes it
// The Update loop handles removal, so we check prediction here
int activeAfterDeath = 0;
foreach (var e in _enemies)
{
    if (e.IsActive && e != enemy) activeAfterDeath++;
}
if (activeAfterDeath == 0)
{
    OnAllEnemiesDefeated?.Invoke();
}
```

Wait, this is complex. Simpler: track if we've fired the event this wave.
Add a field:
```csharp
private bool _allDefeatedFired = false;
```

In SpawnWave, reset it:
```csharp
_allDefeatedFired = false;
```

In Update, after the removal loop:
```csharp
// Fire all-defeated event once when enemies are cleared
if (_enemies.Count == 0 && !_allDefeatedFired && _currentWave > 0)
{
    _allDefeatedFired = true;
    OnAllEnemiesDefeated?.Invoke();
}
```

Also reset in Reset():
```csharp
_allDefeatedFired = false;
```
  </action>
  <verify>File compiles without errors: `dotnet build Berzerk/Berzerk.csproj`</verify>
  <done>EnemyManager has OnAllEnemiesDefeated event that fires exactly once when room is cleared</done>
</task>

<task type="auto">
  <name>Task 2: Integrate RoomManager and RoomRenderer into BerzerkGame</name>
  <files>Berzerk/BerzerkGame.cs</files>
  <action>
Add room system integration to BerzerkGame:

1. Add using statement at top:
```csharp
using Berzerk.Source.Rooms;
```

2. Add fields after enemy system fields (around line 52):
```csharp
// Room system
private RoomManager _roomManager;
private RoomRenderer _roomRenderer;
private int _roomsCleared = 0;
```

3. In Initialize(), after enemy system init (around line 103), add:
```csharp
// Initialize room system
_roomManager = new RoomManager();
_roomManager.Initialize();

// Wire room clear event
_roomManager.OnRoomCleared += () =>
{
    Console.WriteLine("All doors are open! Find an exit.");
};

// Wire room transition event
_roomManager.OnRoomTransition += HandleRoomTransition;
```

4. In LoadContent(), after enemy renderer init (around line 151):
```csharp
// Initialize room renderer
_roomRenderer = new RoomRenderer(GraphicsDevice);
```

5. Replace test wall setup with room geometry. Find this block:
```csharp
// Set up test collision walls
_testWalls = ThirdPersonCamera.CreateTestWalls();
_camera.SetCollisionGeometry(_testWalls);
_projectileManager.SetWallColliders(_testWalls);
```
Replace with:
```csharp
// Set up room collision geometry (replaces test walls)
var roomColliders = _roomManager.GetCollisionGeometry();
_camera.SetCollisionGeometry(roomColliders);
_projectileManager.SetWallColliders(roomColliders);
```

6. After enemy spawn and attack callback wiring, add:
```csharp
// Wire enemy manager to room manager for room clear detection
_enemyManager.OnAllEnemiesDefeated += _roomManager.HandleAllEnemiesDefeated;
```

7. In UpdatePlaying(), add room manager update after enemy manager update:
```csharp
// Update room system (door animations, transition detection)
_roomManager.Update(deltaTime, _playerController.Transform.Position);
```

8. Add new method for room transition handling:
```csharp
private void HandleRoomTransition(Direction exitDirection)
{
    _roomsCleared++;
    Console.WriteLine($"Room {_roomsCleared} cleared! Entering new room...");

    // Reset room state
    _roomManager.TransitionToNewRoom();

    // Clear projectiles (don't carry across rooms)
    _projectileManager.DeactivateAll();

    // Reset and respawn enemies with progressive difficulty
    _enemyManager.Reset();
    int enemyCount = Math.Min(3 + _roomsCleared, 10); // 3 base + 1 per room, max 10
    _enemyManager.SpawnWave(enemyCount, _playerController.Transform.Position);

    // Re-wire attack callback for new enemies
    _enemyManager.SetAttackCallback((damage, direction) =>
    {
        if (_gameState != GameState.Playing) return;
        _healthSystem.TakeDamage(damage);
        _playerController.ApplyKnockback(direction, 8f);
        Console.WriteLine($"Enemy attacked! -{damage} HP");
    });

    // Re-wire room clear event for new wave
    // (Already wired to _roomManager.HandleAllEnemiesDefeated)

    // Update collision geometry (door states changed)
    var roomColliders = _roomManager.GetCollisionGeometry();
    _camera.SetCollisionGeometry(roomColliders);
    _projectileManager.SetWallColliders(roomColliders);

    // Move player to entry position
    Vector3 spawnPos = _roomManager.GetSpawnPositionForEntry(exitDirection);
    _playerController.Transform.Position = spawnPos;

    Console.WriteLine($"Spawned {enemyCount} enemies. Player at {spawnPos}");
}
```

9. In RestartGame(), add room reset:
```csharp
// Reset room system
_roomManager.Reset();
_roomsCleared = 0;

// Update collision geometry
var roomColliders = _roomManager.GetCollisionGeometry();
_camera.SetCollisionGeometry(roomColliders);
_projectileManager.SetWallColliders(roomColliders);
```

10. In Draw(), replace test wall rendering with room rendering. Find:
```csharp
// Draw collision walls
_debugRenderer.DrawBoundingBoxes(_testWalls, _camera.ViewMatrix, _camera.ProjectionMatrix, Color.White);
```
Replace with:
```csharp
// Draw room (walls and doors)
_roomRenderer.Draw(_roomManager.CurrentRoom, _camera.ViewMatrix, _camera.ProjectionMatrix);
```

11. Remove the old _testWalls field (line ~32) and ThirdPersonCamera.CreateTestWalls() is no longer called directly.
  </action>
  <verify>Project compiles and runs: `dotnet build Berzerk/Berzerk.csproj && dotnet run --project Berzerk/Berzerk.csproj` (then exit with Escape)</verify>
  <done>BerzerkGame integrates RoomManager and RoomRenderer; room collision replaces test walls; door progression works with enemy spawns</done>
</task>

<task type="auto">
  <name>Task 3: Add DeactivateAll method to ProjectileManager</name>
  <files>Berzerk/Source/Combat/ProjectileManager.cs</files>
  <action>
Add method to clear all active projectiles (for room transitions):

Find ProjectileManager class and add this method:

```csharp
/// <summary>
/// Deactivate all active projectiles (for room transitions).
/// </summary>
public void DeactivateAll()
{
    foreach (var projectile in _activeProjectiles)
    {
        projectile.Deactivate();
    }
    // Pool cleanup happens in next Update cycle
}
```

If _activeProjectiles is not directly accessible (might be managed differently), check the existing structure. Based on standard pooling pattern, this should work. If needed, iterate and call Deactivate() on each, then let normal Update cycle return them to pool.
  </action>
  <verify>File compiles without errors: `dotnet build Berzerk/Berzerk.csproj`</verify>
  <done>ProjectileManager has DeactivateAll() method for clearing projectiles on room transition</done>
</task>

</tasks>

<verification>
Full verification sequence:
```bash
dotnet build Berzerk/Berzerk.csproj && echo "BUILD SUCCESS"
```

Then manual verification (run game):
1. Start game - see room with 4 colored doors (red = closed)
2. Kill all 3 enemies with laser
3. After 0.5s, doors turn green (open)
4. Walk into any open door
5. Room resets with closed doors and new enemies (4 enemies second room)
6. Console shows: "Room cleared!", "Doors are open!", "Entering new room...", enemy count

Expected console output sequence:
- "Room cleared! Doors opening in 0.5s..."
- "Doors are now open!"
- "Player entered [Direction] door! Transitioning..."
- "Room 1 cleared! Entering new room..."
- "Spawned N enemies. Player at (x,y,z)"
</verification>

<success_criteria>
1. Project compiles without errors
2. Game runs with room geometry (30x30 room with maze walls)
3. 4 doors visible at cardinal positions (red when closed)
4. Killing all enemies causes doors to turn green after 0.5s delay
5. Walking into open door triggers transition (console message)
6. New room spawns with fresh enemies (3 + rooms_cleared, max 10)
7. Player position changes to entry door location
8. Doors reset to closed (red) in new room
9. Game restart resets room counter and door states
</success_criteria>

<output>
After completion, create `.planning/phases/06-room-system-progression/06-04-SUMMARY.md`
</output>
