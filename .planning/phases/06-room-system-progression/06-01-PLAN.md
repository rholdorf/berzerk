---
phase: 06-room-system-progression
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Berzerk/Source/Rooms/Direction.cs
  - Berzerk/Source/Rooms/DoorState.cs
  - Berzerk/Source/Rooms/Door.cs
  - Berzerk/Source/Rooms/Room.cs
autonomous: true

must_haves:
  truths:
    - "Room class holds wall BoundingBoxes for collision"
    - "Room class holds doors at four cardinal positions"
    - "Doors have state (Closed/Opening/Open) and trigger volumes"
    - "Room provides spawn points for enemy placement"
  artifacts:
    - path: "Berzerk/Source/Rooms/Direction.cs"
      provides: "Cardinal direction enum (North/South/East/West)"
      contains: "enum Direction"
    - path: "Berzerk/Source/Rooms/DoorState.cs"
      provides: "Door state enum for FSM"
      contains: "enum DoorState"
    - path: "Berzerk/Source/Rooms/Door.cs"
      provides: "Door with state machine and trigger volume"
      contains: "class Door"
    - path: "Berzerk/Source/Rooms/Room.cs"
      provides: "Room with walls, doors, and spawn points"
      contains: "class Room"
  key_links:
    - from: "Berzerk/Source/Rooms/Room.cs"
      to: "Berzerk/Source/Rooms/Door.cs"
      via: "Dictionary<Direction, Door>"
      pattern: "Doors\\[Direction"
    - from: "Berzerk/Source/Rooms/Door.cs"
      to: "Microsoft.Xna.Framework.BoundingBox"
      via: "TriggerVolume and CollisionBox properties"
      pattern: "BoundingBox"
---

<objective>
Create core room data structures: Room class with walls, doors, and spawn points; Door class with state machine and trigger volumes; supporting enums for direction and door state.

Purpose: Establish the foundation for room-based progression. Room holds static geometry (walls), interactive elements (doors with state), and enemy spawn metadata.
Output: Four source files providing complete room data model ready for manager integration.
</objective>

<execution_context>
@/Users/rui/.claude/get-shit-done/workflows/execute-plan.md
@/Users/rui/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-room-system-progression/06-RESEARCH.md

Key patterns from research:
- Room as passive data container (no Update/Draw - manager handles logic)
- Door state machine: Closed -> Opening (0.5s animation) -> Open
- BoundingBox for wall collision (matches existing ThirdPersonCamera.CreateTestWalls pattern)
- Door trigger volumes extend inward from door position (2x2x2 units inside room)
- Door collision box only active when Closed (removed from collision checks when Open)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create direction and door state enums</name>
  <files>
    Berzerk/Source/Rooms/Direction.cs
    Berzerk/Source/Rooms/DoorState.cs
  </files>
  <action>
Create two enum files in new Berzerk/Source/Rooms/ directory:

**Direction.cs:**
```csharp
namespace Berzerk.Source.Rooms;

/// <summary>
/// Cardinal directions for room doors and transitions.
/// </summary>
public enum Direction
{
    North,  // -Z direction (forward in MonoGame)
    South,  // +Z direction
    East,   // +X direction
    West    // -X direction
}
```

**DoorState.cs:**
```csharp
namespace Berzerk.Source.Rooms;

/// <summary>
/// Door state for FSM transitions.
/// Closed -> Opening (animation) -> Open
/// </summary>
public enum DoorState
{
    Closed,   // Door blocks passage, collision active
    Opening,  // Transitioning (0.5s), collision already removed
    Open      // Door allows passage, no collision
}
```
  </action>
  <verify>Files compile without errors: `dotnet build Berzerk/Berzerk.csproj`</verify>
  <done>Direction enum has 4 cardinal values; DoorState enum has 3 states matching FSM design</done>
</task>

<task type="auto">
  <name>Task 2: Create Door class with state machine and trigger volumes</name>
  <files>Berzerk/Source/Rooms/Door.cs</files>
  <action>
Create Door class that manages door state and collision:

```csharp
using Microsoft.Xna.Framework;

namespace Berzerk.Source.Rooms;

/// <summary>
/// Door at room boundary with state machine and trigger volumes.
/// Trigger volume detects player entry; collision box blocks when closed.
/// </summary>
public class Door
{
    public Direction Facing { get; }
    public Vector3 Position { get; }
    public DoorState State { get; private set; } = DoorState.Closed;
    public BoundingBox TriggerVolume { get; private set; }
    public BoundingBox CollisionBox { get; private set; }

    private float _openingProgress = 0f;
    private const float OPENING_DURATION = 0.5f;

    // Door dimensions
    private const float DOOR_WIDTH = 4f;     // Width of door opening
    private const float DOOR_HEIGHT = 5f;    // Height of door/wall
    private const float TRIGGER_DEPTH = 2f;  // Trigger extends into room
    private const float WALL_THICKNESS = 1f; // Thickness of door collision

    public Door(Direction facing, Vector3 position)
    {
        Facing = facing;
        Position = position;
        CreateVolumes();
    }

    private void CreateVolumes()
    {
        float halfWidth = DOOR_WIDTH / 2f;

        // Create trigger and collision volumes based on facing direction
        // Trigger extends INTO room, collision is AT door position
        switch (Facing)
        {
            case Direction.North: // Door at -Z edge, trigger extends +Z (south into room)
                TriggerVolume = new BoundingBox(
                    new Vector3(Position.X - halfWidth, 0, Position.Z),
                    new Vector3(Position.X + halfWidth, DOOR_HEIGHT, Position.Z + TRIGGER_DEPTH)
                );
                CollisionBox = new BoundingBox(
                    new Vector3(Position.X - halfWidth, 0, Position.Z - WALL_THICKNESS / 2),
                    new Vector3(Position.X + halfWidth, DOOR_HEIGHT, Position.Z + WALL_THICKNESS / 2)
                );
                break;

            case Direction.South: // Door at +Z edge, trigger extends -Z (north into room)
                TriggerVolume = new BoundingBox(
                    new Vector3(Position.X - halfWidth, 0, Position.Z - TRIGGER_DEPTH),
                    new Vector3(Position.X + halfWidth, DOOR_HEIGHT, Position.Z)
                );
                CollisionBox = new BoundingBox(
                    new Vector3(Position.X - halfWidth, 0, Position.Z - WALL_THICKNESS / 2),
                    new Vector3(Position.X + halfWidth, DOOR_HEIGHT, Position.Z + WALL_THICKNESS / 2)
                );
                break;

            case Direction.East: // Door at +X edge, trigger extends -X (west into room)
                TriggerVolume = new BoundingBox(
                    new Vector3(Position.X - TRIGGER_DEPTH, 0, Position.Z - halfWidth),
                    new Vector3(Position.X, DOOR_HEIGHT, Position.Z + halfWidth)
                );
                CollisionBox = new BoundingBox(
                    new Vector3(Position.X - WALL_THICKNESS / 2, 0, Position.Z - halfWidth),
                    new Vector3(Position.X + WALL_THICKNESS / 2, DOOR_HEIGHT, Position.Z + halfWidth)
                );
                break;

            case Direction.West: // Door at -X edge, trigger extends +X (east into room)
                TriggerVolume = new BoundingBox(
                    new Vector3(Position.X, 0, Position.Z - halfWidth),
                    new Vector3(Position.X + TRIGGER_DEPTH, DOOR_HEIGHT, Position.Z + halfWidth)
                );
                CollisionBox = new BoundingBox(
                    new Vector3(Position.X - WALL_THICKNESS / 2, 0, Position.Z - halfWidth),
                    new Vector3(Position.X + WALL_THICKNESS / 2, DOOR_HEIGHT, Position.Z + halfWidth)
                );
                break;
        }
    }

    /// <summary>
    /// Begin door opening animation. Only valid from Closed state.
    /// </summary>
    public void Open()
    {
        if (State == DoorState.Closed)
        {
            State = DoorState.Opening;
            _openingProgress = 0f;
        }
    }

    /// <summary>
    /// Reset door to closed state (for room transitions).
    /// </summary>
    public void Close()
    {
        State = DoorState.Closed;
        _openingProgress = 0f;
    }

    /// <summary>
    /// Update door state machine. Transitions Opening -> Open after duration.
    /// </summary>
    public void Update(float deltaTime)
    {
        if (State == DoorState.Opening)
        {
            _openingProgress += deltaTime;
            if (_openingProgress >= OPENING_DURATION)
            {
                _openingProgress = OPENING_DURATION;
                State = DoorState.Open;
            }
        }
    }

    /// <summary>
    /// Get opening progress (0-1) for animation purposes.
    /// </summary>
    public float OpeningProgress => _openingProgress / OPENING_DURATION;

    /// <summary>
    /// Check if player can pass through this door.
    /// </summary>
    public bool CanPlayerEnter() => State == DoorState.Open;

    /// <summary>
    /// Check if player position is inside trigger volume.
    /// </summary>
    public bool IsPlayerInTrigger(Vector3 playerPos)
    {
        return TriggerVolume.Contains(playerPos) == ContainmentType.Contains;
    }

    /// <summary>
    /// Get collision box only if door is closed, null otherwise.
    /// Used for dynamic collision list building.
    /// </summary>
    public BoundingBox? GetActiveCollision()
    {
        return State == DoorState.Closed ? CollisionBox : null;
    }
}
```
  </action>
  <verify>File compiles without errors: `dotnet build Berzerk/Berzerk.csproj`</verify>
  <done>Door class has state machine (Closed/Opening/Open), trigger volume for entry detection, collision box for blocking, and state-dependent collision getter</done>
</task>

<task type="auto">
  <name>Task 3: Create Room class with walls, doors, and spawn points</name>
  <files>Berzerk/Source/Rooms/Room.cs</files>
  <action>
Create Room class as data container for room geometry:

```csharp
using Microsoft.Xna.Framework;
using System.Collections.Generic;

namespace Berzerk.Source.Rooms;

/// <summary>
/// Room data container with walls, doors, and enemy spawn points.
/// Passive data structure - RoomManager handles logic.
/// </summary>
public class Room
{
    public List<BoundingBox> Walls { get; private set; }
    public Dictionary<Direction, Door> Doors { get; private set; }
    public List<Vector3> EnemySpawnPoints { get; private set; }

    // Room dimensions (matching existing game area)
    private const float ROOM_SIZE = 30f;        // 30x30 room
    private const float HALF_SIZE = ROOM_SIZE / 2f;
    private const float WALL_THICKNESS = 1f;
    private const float WALL_HEIGHT = 5f;
    private const float DOOR_WIDTH = 4f;        // Opening in wall for door

    public Room()
    {
        Walls = CreateMazeWalls();
        Doors = CreateDoors();
        EnemySpawnPoints = CreateSpawnPoints();
    }

    /// <summary>
    /// Create handcrafted maze walls with door openings at cardinal positions.
    /// Based on existing ThirdPersonCamera.CreateTestWalls pattern.
    /// </summary>
    private List<BoundingBox> CreateMazeWalls()
    {
        var walls = new List<BoundingBox>();
        float doorHalf = DOOR_WIDTH / 2f;

        // North wall (-Z edge) with door opening at center
        // Left segment
        walls.Add(new BoundingBox(
            new Vector3(-HALF_SIZE, 0, -HALF_SIZE),
            new Vector3(-doorHalf, WALL_HEIGHT, -HALF_SIZE + WALL_THICKNESS)
        ));
        // Right segment
        walls.Add(new BoundingBox(
            new Vector3(doorHalf, 0, -HALF_SIZE),
            new Vector3(HALF_SIZE, WALL_HEIGHT, -HALF_SIZE + WALL_THICKNESS)
        ));

        // South wall (+Z edge) with door opening at center
        walls.Add(new BoundingBox(
            new Vector3(-HALF_SIZE, 0, HALF_SIZE - WALL_THICKNESS),
            new Vector3(-doorHalf, WALL_HEIGHT, HALF_SIZE)
        ));
        walls.Add(new BoundingBox(
            new Vector3(doorHalf, 0, HALF_SIZE - WALL_THICKNESS),
            new Vector3(HALF_SIZE, WALL_HEIGHT, HALF_SIZE)
        ));

        // East wall (+X edge) with door opening at center
        walls.Add(new BoundingBox(
            new Vector3(HALF_SIZE - WALL_THICKNESS, 0, -HALF_SIZE),
            new Vector3(HALF_SIZE, WALL_HEIGHT, -doorHalf)
        ));
        walls.Add(new BoundingBox(
            new Vector3(HALF_SIZE - WALL_THICKNESS, 0, doorHalf),
            new Vector3(HALF_SIZE, WALL_HEIGHT, HALF_SIZE)
        ));

        // West wall (-X edge) with door opening at center
        walls.Add(new BoundingBox(
            new Vector3(-HALF_SIZE, 0, -HALF_SIZE),
            new Vector3(-HALF_SIZE + WALL_THICKNESS, WALL_HEIGHT, -doorHalf)
        ));
        walls.Add(new BoundingBox(
            new Vector3(-HALF_SIZE, 0, doorHalf),
            new Vector3(-HALF_SIZE + WALL_THICKNESS, WALL_HEIGHT, HALF_SIZE)
        ));

        // Interior maze walls (4 pillars for cover, matching Berzerk style)
        float pillarOffset = 7f;
        float pillarSize = 2f;

        // Northwest pillar
        walls.Add(new BoundingBox(
            new Vector3(-pillarOffset - pillarSize, 0, -pillarOffset - pillarSize),
            new Vector3(-pillarOffset, WALL_HEIGHT - 1, -pillarOffset)
        ));
        // Northeast pillar
        walls.Add(new BoundingBox(
            new Vector3(pillarOffset, 0, -pillarOffset - pillarSize),
            new Vector3(pillarOffset + pillarSize, WALL_HEIGHT - 1, -pillarOffset)
        ));
        // Southwest pillar
        walls.Add(new BoundingBox(
            new Vector3(-pillarOffset - pillarSize, 0, pillarOffset),
            new Vector3(-pillarOffset, WALL_HEIGHT - 1, pillarOffset + pillarSize)
        ));
        // Southeast pillar
        walls.Add(new BoundingBox(
            new Vector3(pillarOffset, 0, pillarOffset),
            new Vector3(pillarOffset + pillarSize, WALL_HEIGHT - 1, pillarOffset + pillarSize)
        ));

        // Center horizontal wall (creates maze feel)
        walls.Add(new BoundingBox(
            new Vector3(-3f, 0, -1f),
            new Vector3(3f, WALL_HEIGHT - 1, 1f)
        ));

        return walls;
    }

    /// <summary>
    /// Create doors at cardinal positions.
    /// </summary>
    private Dictionary<Direction, Door> CreateDoors()
    {
        return new Dictionary<Direction, Door>
        {
            { Direction.North, new Door(Direction.North, new Vector3(0, 0, -HALF_SIZE)) },
            { Direction.South, new Door(Direction.South, new Vector3(0, 0, HALF_SIZE)) },
            { Direction.East, new Door(Direction.East, new Vector3(HALF_SIZE, 0, 0)) },
            { Direction.West, new Door(Direction.West, new Vector3(-HALF_SIZE, 0, 0)) }
        };
    }

    /// <summary>
    /// Create enemy spawn points around room perimeter (away from doors and center).
    /// </summary>
    private List<Vector3> CreateSpawnPoints()
    {
        return new List<Vector3>
        {
            // Corner zones (primary spawn areas, far from doors)
            new Vector3(-10f, 0.5f, -10f),  // NW corner
            new Vector3(10f, 0.5f, -10f),   // NE corner
            new Vector3(-10f, 0.5f, 10f),   // SW corner
            new Vector3(10f, 0.5f, 10f),    // SE corner

            // Mid-wall zones (secondary spawns, between doors and corners)
            new Vector3(-10f, 0.5f, 0),     // West mid
            new Vector3(10f, 0.5f, 0),      // East mid
            new Vector3(0, 0.5f, -10f),     // North mid (near door, use carefully)
            new Vector3(0, 0.5f, 10f),      // South mid (near door, use carefully)
        };
    }

    /// <summary>
    /// Update all doors (called by RoomManager).
    /// </summary>
    public void UpdateDoors(float deltaTime)
    {
        foreach (var door in Doors.Values)
        {
            door.Update(deltaTime);
        }
    }

    /// <summary>
    /// Open all doors (called when room is cleared).
    /// </summary>
    public void OpenAllDoors()
    {
        foreach (var door in Doors.Values)
        {
            door.Open();
        }
    }

    /// <summary>
    /// Close all doors (called on room transition).
    /// </summary>
    public void CloseAllDoors()
    {
        foreach (var door in Doors.Values)
        {
            door.Close();
        }
    }

    /// <summary>
    /// Get all collision geometry including walls and closed door colliders.
    /// </summary>
    public List<BoundingBox> GetCollisionGeometry()
    {
        var colliders = new List<BoundingBox>(Walls);

        foreach (var door in Doors.Values)
        {
            var doorCollision = door.GetActiveCollision();
            if (doorCollision.HasValue)
            {
                colliders.Add(doorCollision.Value);
            }
        }

        return colliders;
    }
}
```
  </action>
  <verify>File compiles without errors: `dotnet build Berzerk/Berzerk.csproj`</verify>
  <done>Room class has wall BoundingBoxes with door openings, 4 cardinal doors, spawn points for enemies, and methods for door control and collision geometry retrieval</done>
</task>

</tasks>

<verification>
All verification in single command:
```bash
dotnet build Berzerk/Berzerk.csproj && echo "BUILD SUCCESS - All room infrastructure files compile"
```

Expected: BUILD SUCCESS with no errors. Files exist in Berzerk/Source/Rooms/:
- Direction.cs (enum with 4 values)
- DoorState.cs (enum with 3 states)
- Door.cs (class with state machine and volumes)
- Room.cs (class with walls, doors, spawn points)
</verification>

<success_criteria>
1. Four source files created in Berzerk/Source/Rooms/
2. Project compiles without errors
3. Room class provides List<BoundingBox> Walls with door openings at cardinal positions
4. Room class provides Dictionary<Direction, Door> with 4 doors
5. Door class has DoorState property that transitions Closed -> Opening -> Open
6. Door class provides GetActiveCollision() that returns null when not Closed
7. Room.GetCollisionGeometry() returns combined walls + closed door colliders
</success_criteria>

<output>
After completion, create `.planning/phases/06-room-system-progression/06-01-SUMMARY.md`
</output>
